[{"filePath":"E:\\Development\\aluminify\\codebase-cleanup\\src\\analyzers\\auth-pattern-analyzer.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":486,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":486,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15383,15386],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15383,15386],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Auth Pattern Analyzer\r\n *\r\n * Analyzes authentication and authorization patterns in the codebase\r\n * to identify inconsistencies, redundancies, and unnecessary complexity.\r\n *\r\n * Detects:\r\n * - Multiple auth client instantiation patterns\r\n * - Inconsistent permission checking approaches\r\n * - Inconsistent session management\r\n * - Redundant auth middleware\r\n * - Unnecessary auth wrapper functions\r\n */\r\n\r\nimport { SourceFile, Node, ArrowFunction } from \"ts-morph\";\r\nimport { BasePatternAnalyzer } from \"./pattern-analyzer.js\";\r\nimport type { FileInfo, Issue, FileCategory } from \"../types.js\";\r\n\r\n/**\r\n * Pattern for tracking auth client instantiation\r\n */\r\ninterface AuthClientPattern {\r\n  functionName: string;\r\n  node: Node;\r\n  file: string;\r\n}\r\n\r\n/**\r\n * Pattern for tracking permission checks\r\n */\r\ninterface PermissionCheckPattern {\r\n  type: \"role\" | \"permission\" | \"custom\";\r\n  node: Node;\r\n  file: string;\r\n}\r\n\r\n/**\r\n * Pattern for tracking session management\r\n */\r\ninterface SessionPattern {\r\n  type: \"cookie\" | \"token\" | \"supabase\" | \"custom\";\r\n  node: Node;\r\n  file: string;\r\n}\r\n\r\n/**\r\n * Analyzer for authentication and authorization patterns\r\n */\r\nexport class AuthPatternAnalyzer extends BasePatternAnalyzer {\r\n  readonly name = \"AuthPatternAnalyzer\";\r\n\r\n  private authClientPatterns: AuthClientPattern[] = [];\r\n  private permissionCheckPatterns: PermissionCheckPattern[] = [];\r\n  private sessionPatterns: SessionPattern[] = [];\r\n\r\n  /**\r\n   * Get supported file types for this analyzer\r\n   */\r\n  getSupportedFileTypes(): FileCategory[] {\r\n    return [\"api-route\", \"service\", \"middleware\", \"util\"];\r\n  }\r\n\r\n  /**\r\n   * Analyze a file for auth-related issues\r\n   */\r\n  async analyze(file: FileInfo, ast: SourceFile): Promise<Issue[]> {\r\n    const issues: Issue[] = [];\r\n\r\n    // Task 5.1: Detect auth client instantiation patterns\r\n    issues.push(...this.detectAuthClientPatterns(file, ast));\r\n\r\n    // Task 5.2: Detect auth inconsistencies\r\n    issues.push(...this.detectAuthInconsistencies(file, ast));\r\n\r\n    // Task 5.3: Detect unnecessary auth adapters\r\n    issues.push(...this.detectUnnecessaryAuthAdapters(file, ast));\r\n\r\n    return issues;\r\n  }\r\n\r\n  // ============================================================================\r\n  // Task 5.1: Auth Client Instantiation Pattern Detection\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Detect multiple patterns for creating auth clients\r\n   * Validates Requirements: 2.1\r\n   */\r\n  private detectAuthClientPatterns(file: FileInfo, ast: SourceFile): Issue[] {\r\n    const issues: Issue[] = [];\r\n    const callExpressions = this.getCallExpressions(ast);\r\n\r\n    // Common auth client creation patterns\r\n    const authClientPatterns = [\r\n      \"createClient\",\r\n      \"getSupabaseClient\",\r\n      \"initSupabase\",\r\n      \"createSupabaseClient\",\r\n      \"getAuthClient\",\r\n      \"initAuth\",\r\n      \"createAuthClient\",\r\n      \"supabaseClient\",\r\n      \"getClient\",\r\n      \"initClient\",\r\n    ];\r\n\r\n    for (const call of callExpressions) {\r\n      const callText = call.getText();\r\n\r\n      // Check if this is an auth client creation call\r\n      for (const pattern of authClientPatterns) {\r\n        if (callText.includes(pattern)) {\r\n          // Track this pattern\r\n          this.authClientPatterns.push({\r\n            functionName: pattern,\r\n            node: call,\r\n            file: file.relativePath,\r\n          });\r\n\r\n          // If we've seen multiple different patterns, flag as inconsistent\r\n          const uniquePatterns = new Set(\r\n            this.authClientPatterns.map((p) => p.functionName),\r\n          );\r\n          if (uniquePatterns.size > 1) {\r\n            issues.push(\r\n              this.createIssue({\r\n                type: \"inconsistent-pattern\",\r\n                severity: \"medium\",\r\n                category: \"authentication\",\r\n                file: file.relativePath,\r\n                node: call,\r\n                description: `Inconsistent auth client instantiation pattern detected. Found ${uniquePatterns.size} different patterns: ${Array.from(uniquePatterns).join(\", \")}`,\r\n                recommendation:\r\n                  \"Standardize auth client creation to use a single pattern across the codebase. Consider creating a centralized auth client factory function.\",\r\n                estimatedEffort: \"medium\",\r\n                tags: [\"auth\", \"inconsistency\", \"client-instantiation\"],\r\n              }),\r\n            );\r\n          }\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    return issues;\r\n  }\r\n\r\n  // ============================================================================\r\n  // Task 5.2: Auth Inconsistency Detection\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Detect inconsistent permission checking, session management, and redundant middleware\r\n   * Validates Requirements: 2.2, 2.3, 2.4\r\n   */\r\n  private detectAuthInconsistencies(file: FileInfo, ast: SourceFile): Issue[] {\r\n    const issues: Issue[] = [];\r\n\r\n    // Detect inconsistent permission checking\r\n    issues.push(...this.detectInconsistentPermissionChecks(file, ast));\r\n\r\n    // Detect inconsistent session management\r\n    issues.push(...this.detectInconsistentSessionManagement(file, ast));\r\n\r\n    // Detect redundant auth middleware\r\n    issues.push(...this.detectRedundantAuthMiddleware(file, ast));\r\n\r\n    return issues;\r\n  }\r\n\r\n  /**\r\n   * Detect inconsistent permission checking patterns\r\n   * Validates Requirements: 2.2\r\n   */\r\n  private detectInconsistentPermissionChecks(\r\n    file: FileInfo,\r\n    ast: SourceFile,\r\n  ): Issue[] {\r\n    const issues: Issue[] = [];\r\n    const callExpressions = this.getCallExpressions(ast);\r\n\r\n    // Permission checking patterns\r\n    const roleCheckPatterns = [\r\n      \"checkRole\",\r\n      \"hasRole\",\r\n      \"isRole\",\r\n      \"role ===\",\r\n      \"role ==\",\r\n    ];\r\n    const permissionCheckPatterns = [\r\n      \"checkPermission\",\r\n      \"hasPermission\",\r\n      \"can\",\r\n      \"permissions.includes\",\r\n    ];\r\n    const customCheckPatterns = [\r\n      \"checkAuth\",\r\n      \"isAuthorized\",\r\n      \"authorize\",\r\n      \"verifyAccess\",\r\n    ];\r\n\r\n    for (const call of callExpressions) {\r\n      const callText = call.getText();\r\n\r\n      // Identify the type of permission check\r\n      let checkType: \"role\" | \"permission\" | \"custom\" | null = null;\r\n\r\n      if (roleCheckPatterns.some((pattern) => callText.includes(pattern))) {\r\n        checkType = \"role\";\r\n      } else if (\r\n        permissionCheckPatterns.some((pattern) => callText.includes(pattern))\r\n      ) {\r\n        checkType = \"permission\";\r\n      } else if (\r\n        customCheckPatterns.some((pattern) => callText.includes(pattern))\r\n      ) {\r\n        checkType = \"custom\";\r\n      }\r\n\r\n      if (checkType) {\r\n        this.permissionCheckPatterns.push({\r\n          type: checkType,\r\n          node: call,\r\n          file: file.relativePath,\r\n        });\r\n\r\n        // If we've seen multiple different check types, flag as inconsistent\r\n        const uniqueCheckTypes = new Set(\r\n          this.permissionCheckPatterns.map((p) => p.type),\r\n        );\r\n        if (uniqueCheckTypes.size > 1) {\r\n          issues.push(\r\n            this.createIssue({\r\n              type: \"inconsistent-pattern\",\r\n              severity: \"high\",\r\n              category: \"authentication\",\r\n              file: file.relativePath,\r\n              node: call,\r\n              description: `Inconsistent permission checking approach detected. Found ${uniqueCheckTypes.size} different approaches: ${Array.from(uniqueCheckTypes).join(\", \")}`,\r\n              recommendation:\r\n                \"Standardize permission checking to use a single approach (either role-based, permission-based, or a custom unified approach). This improves maintainability and reduces security risks.\",\r\n              estimatedEffort: \"medium\",\r\n              tags: [\"auth\", \"permissions\", \"inconsistency\", \"security\"],\r\n            }),\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    return issues;\r\n  }\r\n\r\n  /**\r\n   * Detect inconsistent session management\r\n   * Validates Requirements: 2.4\r\n   */\r\n  private detectInconsistentSessionManagement(\r\n    file: FileInfo,\r\n    ast: SourceFile,\r\n  ): Issue[] {\r\n    const issues: Issue[] = [];\r\n    const callExpressions = this.getCallExpressions(ast);\r\n\r\n    // Session management patterns\r\n    const cookiePatterns = [\"cookies()\", \"getCookie\", \"setCookie\", \"cookie.\"];\r\n    const tokenPatterns = [\"getToken\", \"setToken\", \"token\", \"jwt\", \"bearer\"];\r\n    const supabasePatterns = [\r\n      \"getSession\",\r\n      \"setSession\",\r\n      \"session.user\",\r\n      \"auth.getUser\",\r\n    ];\r\n    const customPatterns = [\"getAuth\", \"setAuth\", \"authSession\"];\r\n\r\n    for (const call of callExpressions) {\r\n      const callText = call.getText();\r\n\r\n      // Identify the type of session management\r\n      let sessionType: \"cookie\" | \"token\" | \"supabase\" | \"custom\" | null = null;\r\n\r\n      if (cookiePatterns.some((pattern) => callText.includes(pattern))) {\r\n        sessionType = \"cookie\";\r\n      } else if (tokenPatterns.some((pattern) => callText.includes(pattern))) {\r\n        sessionType = \"token\";\r\n      } else if (\r\n        supabasePatterns.some((pattern) => callText.includes(pattern))\r\n      ) {\r\n        sessionType = \"supabase\";\r\n      } else if (customPatterns.some((pattern) => callText.includes(pattern))) {\r\n        sessionType = \"custom\";\r\n      }\r\n\r\n      if (sessionType) {\r\n        this.sessionPatterns.push({\r\n          type: sessionType,\r\n          node: call,\r\n          file: file.relativePath,\r\n        });\r\n\r\n        // If we've seen multiple different session types, flag as inconsistent\r\n        const uniqueSessionTypes = new Set(\r\n          this.sessionPatterns.map((p) => p.type),\r\n        );\r\n        if (uniqueSessionTypes.size > 1) {\r\n          issues.push(\r\n            this.createIssue({\r\n              type: \"inconsistent-pattern\",\r\n              severity: \"high\",\r\n              category: \"authentication\",\r\n              file: file.relativePath,\r\n              node: call,\r\n              description: `Inconsistent session management detected. Found ${uniqueSessionTypes.size} different approaches: ${Array.from(uniqueSessionTypes).join(\", \")}`,\r\n              recommendation:\r\n                \"Standardize session management to use a single approach. For Supabase projects, prefer using Supabase's built-in session management.\",\r\n              estimatedEffort: \"large\",\r\n              tags: [\"auth\", \"session\", \"inconsistency\", \"security\"],\r\n            }),\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    return issues;\r\n  }\r\n\r\n  /**\r\n   * Detect redundant auth middleware\r\n   * Validates Requirements: 2.3\r\n   */\r\n  private detectRedundantAuthMiddleware(\r\n    file: FileInfo,\r\n    ast: SourceFile,\r\n  ): Issue[] {\r\n    const issues: Issue[] = [];\r\n\r\n    // Only check middleware files\r\n    if (\r\n      file.category !== \"middleware\" &&\r\n      !file.relativePath.includes(\"middleware\")\r\n    ) {\r\n      return issues;\r\n    }\r\n\r\n    const functions = [\r\n      ...this.getFunctionDeclarations(ast),\r\n      ...this.getArrowFunctions(ast),\r\n      ...this.getFunctionExpressions(ast),\r\n    ];\r\n\r\n    // Track middleware functions that perform auth checks\r\n    const authMiddlewareFunctions: Node[] = [];\r\n\r\n    for (const func of functions) {\r\n      const funcText = func.getText();\r\n\r\n      // Check if this function performs auth checks\r\n      const authKeywords = [\r\n        \"auth\",\r\n        \"authenticate\",\r\n        \"authorize\",\r\n        \"checkAuth\",\r\n        \"verifyAuth\",\r\n        \"getUser\",\r\n        \"getSession\",\r\n        \"checkPermission\",\r\n        \"checkRole\",\r\n      ];\r\n\r\n      if (\r\n        authKeywords.some((keyword) =>\r\n          funcText.toLowerCase().includes(keyword.toLowerCase()),\r\n        )\r\n      ) {\r\n        authMiddlewareFunctions.push(func);\r\n      }\r\n    }\r\n\r\n    // If we have multiple auth middleware functions in the same file, flag as redundant\r\n    if (authMiddlewareFunctions.length > 1) {\r\n      for (const func of authMiddlewareFunctions) {\r\n        issues.push(\r\n          this.createIssue({\r\n            type: \"code-duplication\",\r\n            severity: \"medium\",\r\n            category: \"authentication\",\r\n            file: file.relativePath,\r\n            node: func,\r\n            description: `Redundant auth middleware detected. Found ${authMiddlewareFunctions.length} auth middleware functions in the same file.`,\r\n            recommendation:\r\n              \"Consolidate auth middleware into a single, reusable function. Consider creating a composable middleware pattern if different auth checks are needed.\",\r\n            estimatedEffort: \"small\",\r\n            tags: [\"auth\", \"middleware\", \"duplication\"],\r\n          }),\r\n        );\r\n      }\r\n    }\r\n\r\n    return issues;\r\n  }\r\n\r\n  // ============================================================================\r\n  // Task 5.3: Unnecessary Auth Adapter Detection\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Detect simple pass-through auth wrapper functions\r\n   * Validates Requirements: 2.5\r\n   */\r\n  private detectUnnecessaryAuthAdapters(\r\n    file: FileInfo,\r\n    ast: SourceFile,\r\n  ): Issue[] {\r\n    const issues: Issue[] = [];\r\n\r\n    const functions = [\r\n      ...this.getFunctionDeclarations(ast),\r\n      ...this.getArrowFunctions(ast),\r\n      ...this.getFunctionExpressions(ast),\r\n    ];\r\n\r\n    for (const func of functions) {\r\n      const _funcText = func.getText();\r\n      const funcName = this.getNodeName(func);\r\n\r\n      // Skip if no name or not auth-related\r\n      if (!funcName || !this.isAuthRelated(funcName)) {\r\n        continue;\r\n      }\r\n\r\n      // Check if this is a simple pass-through wrapper\r\n      if (this.isPassThroughWrapper(func)) {\r\n        issues.push(\r\n          this.createIssue({\r\n            type: \"unnecessary-adapter\",\r\n            severity: \"low\",\r\n            category: \"authentication\",\r\n            file: file.relativePath,\r\n            node: func,\r\n            description: `Unnecessary auth adapter detected: \"${funcName}\". This function appears to be a simple pass-through wrapper that adds no meaningful value.`,\r\n            recommendation:\r\n              \"Remove this wrapper function and call the underlying auth function directly. This reduces code complexity and improves maintainability.\",\r\n            estimatedEffort: \"trivial\",\r\n            tags: [\"auth\", \"adapter\", \"unnecessary\", \"wrapper\"],\r\n          }),\r\n        );\r\n      }\r\n    }\r\n\r\n    return issues;\r\n  }\r\n\r\n  /**\r\n   * Check if a function name is auth-related\r\n   */\r\n  private isAuthRelated(name: string): boolean {\r\n    const authKeywords = [\r\n      \"auth\",\r\n      \"authenticate\",\r\n      \"authorize\",\r\n      \"login\",\r\n      \"logout\",\r\n      \"session\",\r\n      \"user\",\r\n      \"permission\",\r\n      \"role\",\r\n      \"access\",\r\n      \"token\",\r\n      \"credential\",\r\n    ];\r\n\r\n    const lowerName = name.toLowerCase();\r\n    return authKeywords.some((keyword) => lowerName.includes(keyword));\r\n  }\r\n\r\n  /**\r\n   * Check if a function is a simple pass-through wrapper\r\n   */\r\n  private isPassThroughWrapper(func: Node): boolean {\r\n    const funcText = func.getText();\r\n\r\n    // Get the function body\r\n    let body: Node | undefined;\r\n\r\n    if (Node.isFunctionDeclaration(func) || Node.isFunctionExpression(func)) {\r\n      body = (func as any).getBody();\r\n    } else if (Node.isArrowFunction(func)) {\r\n      const _arrowBody = (func as ArrowFunction).getBody();\r\n    }\r\n\r\n    if (!body) {\r\n      return false;\r\n    }\r\n\r\n    const bodyText = body.getText().trim();\r\n\r\n    // Check for simple pass-through patterns:\r\n    // 1. Single return statement with a function call\r\n    // 2. Single line arrow function that just calls another function\r\n    // 3. Function that just returns the result of another function call\r\n\r\n    // Pattern 1: { return someFunction(...) }\r\n    const singleReturnPattern = /^\\{\\s*return\\s+\\w+\\([^)]*\\)\\s*;?\\s*\\}$/;\r\n    if (singleReturnPattern.test(bodyText)) {\r\n      return true;\r\n    }\r\n\r\n    // Pattern 2: Arrow function: (...) => someFunction(...)\r\n    const arrowPassThroughPattern = /^\\w+\\([^)]*\\)$/;\r\n    if (Node.isArrowFunction(func) && arrowPassThroughPattern.test(bodyText)) {\r\n      return true;\r\n    }\r\n\r\n    // Pattern 3: Check if body has only one statement that's a return with a call\r\n    if (Node.isBlock(body)) {\r\n      const statements = body.getStatements();\r\n      if (statements.length === 1) {\r\n        const statement = statements[0];\r\n        if (Node.isReturnStatement(statement)) {\r\n          const expression = statement.getExpression();\r\n          if (expression && Node.isCallExpression(expression)) {\r\n            // This is a simple pass-through: just returns a function call\r\n            return true;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // Pattern 4: Arrow function with single call expression\r\n    if (Node.isArrowFunction(func)) {\r\n      const arrowBody = (func as ArrowFunction).getBody();\r\n      if (Node.isCallExpression(arrowBody)) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\Development\\aluminify\\codebase-cleanup\\src\\analyzers\\component-pattern-analyzer.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":810,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":810,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[24922,24925],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[24922,24925],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":865,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":865,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[27036,27039],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[27036,27039],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":917,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":917,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[29027,29030],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[29027,29030],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Component Pattern Analyzer\r\n *\r\n * Analyzes React component structure and patterns in the codebase to identify\r\n * component quality issues and inconsistencies.\r\n *\r\n * Detects:\r\n * - React function components\r\n * - React class components\r\n * - Component categorization by type\r\n * - Components with business logic that should be in services\r\n * - Excessive prop drilling (more than 3 levels)\r\n * - Duplicate component logic\r\n * - Inconsistent component composition patterns\r\n * - Components mixing concerns (UI + data fetching + business logic)\r\n */\r\n\r\nimport {\r\n  SourceFile,\r\n  Node,\r\n  FunctionDeclaration,\r\n  ArrowFunction,\r\n  ClassDeclaration,\r\n  VariableDeclaration,\r\n} from \"ts-morph\";\r\nimport { BasePatternAnalyzer } from \"./pattern-analyzer.js\";\r\nimport type { FileInfo, Issue, FileCategory } from \"../types.js\";\r\n\r\n/**\r\n * Information about a discovered React component\r\n */\r\ninterface ComponentInfo {\r\n  name: string;\r\n  type: \"function\" | \"class\" | \"arrow\";\r\n  node: Node;\r\n  file: string;\r\n  isExported: boolean;\r\n  hasProps: boolean;\r\n  usesHooks: boolean;\r\n  usesState: boolean;\r\n}\r\n\r\n/**\r\n * Information about a prop chain through component hierarchy\r\n */\r\ninterface PropChain {\r\n  propName: string;\r\n  depth: number;\r\n  componentPath: string[];\r\n  startNode: Node;\r\n}\r\n\r\n/**\r\n * Analyzer for React component patterns\r\n */\r\nexport class ComponentPatternAnalyzer extends BasePatternAnalyzer {\r\n  readonly name = \"ComponentPatternAnalyzer\";\r\n\r\n  private discoveredComponents: ComponentInfo[] = [];\r\n\r\n  /**\r\n   * Get supported file types for this analyzer\r\n   */\r\n  getSupportedFileTypes(): FileCategory[] {\r\n    return [\"component\"];\r\n  }\r\n\r\n  /**\r\n   * Analyze a file for component-related issues\r\n   */\r\n  async analyze(file: FileInfo, ast: SourceFile): Promise<Issue[]> {\r\n    // Reset state for each file analysis\r\n    this.discoveredComponents = [];\r\n\r\n    const issues: Issue[] = [];\r\n\r\n    // Task 7.1: Discover and categorize React components\r\n    issues.push(...this.discoverComponents(file, ast));\r\n\r\n    // Task 7.2: Detect prop drilling\r\n    issues.push(...this.detectPropDrilling(file, ast));\r\n\r\n    // Task 7.3: Detect component pattern inconsistencies and duplicate logic\r\n    issues.push(...this.detectComponentPatternInconsistencies(file, ast));\r\n    issues.push(...this.detectDuplicateComponentLogic(file, ast));\r\n\r\n    return issues;\r\n  }\r\n\r\n  // ============================================================================\r\n  // Task 7.1: Component Discovery and Categorization\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Discover all React components (function and class components) and categorize them\r\n   * Validates Requirements: 6.1\r\n   */\r\n  private discoverComponents(file: FileInfo, ast: SourceFile): Issue[] {\r\n    const issues: Issue[] = [];\r\n\r\n    // Discover function components\r\n    issues.push(...this.discoverFunctionComponents(file, ast));\r\n\r\n    // Discover class components\r\n    issues.push(...this.discoverClassComponents(file, ast));\r\n\r\n    // Discover arrow function components\r\n    issues.push(...this.discoverArrowFunctionComponents(file, ast));\r\n\r\n    return issues;\r\n  }\r\n\r\n  /**\r\n   * Discover React function components (function declarations)\r\n   */\r\n  private discoverFunctionComponents(file: FileInfo, ast: SourceFile): Issue[] {\r\n    const issues: Issue[] = [];\r\n    const functionDeclarations = ast.getFunctions();\r\n\r\n    for (const func of functionDeclarations) {\r\n      const funcName = func.getName();\r\n      if (!funcName) continue;\r\n\r\n      // Check if this is a React component\r\n      if (this.isReactComponent(func, funcName)) {\r\n        const componentInfo: ComponentInfo = {\r\n          name: funcName,\r\n          type: \"function\",\r\n          node: func,\r\n          file: file.relativePath,\r\n          isExported: this.isExported(func),\r\n          hasProps: this.hasParameters(func),\r\n          usesHooks: this.usesReactHooks(func),\r\n          usesState: this.usesStateHook(func),\r\n        };\r\n\r\n        this.discoveredComponents.push(componentInfo);\r\n\r\n        // Log discovery (not an issue, just tracking)\r\n        // We don't create issues for valid components, only for problems\r\n      }\r\n    }\r\n\r\n    return issues;\r\n  }\r\n\r\n  /**\r\n   * Discover React class components\r\n   */\r\n  private discoverClassComponents(file: FileInfo, ast: SourceFile): Issue[] {\r\n    const issues: Issue[] = [];\r\n    const classDeclarations = this.getClassDeclarations(ast);\r\n\r\n    for (const classDecl of classDeclarations) {\r\n      const className = this.getNodeName(classDecl);\r\n      if (!className) continue;\r\n\r\n      // Cast to ClassDeclaration for type safety\r\n      if (!Node.isClassDeclaration(classDecl)) continue;\r\n\r\n      // Check if this class extends React.Component or React.PureComponent\r\n      if (this.isReactClassComponent(classDecl)) {\r\n        const componentInfo: ComponentInfo = {\r\n          name: className,\r\n          type: \"class\",\r\n          node: classDecl,\r\n          file: file.relativePath,\r\n          isExported: this.isExported(classDecl),\r\n          hasProps: this.classHasProps(classDecl),\r\n          usesHooks: false, // Class components don't use hooks\r\n          usesState: this.classHasState(classDecl),\r\n        };\r\n\r\n        this.discoveredComponents.push(componentInfo);\r\n\r\n        // Flag class components as potentially outdated pattern\r\n        // Modern React prefers function components with hooks\r\n        issues.push(\r\n          this.createIssue({\r\n            type: \"legacy-code\",\r\n            severity: \"low\",\r\n            category: \"components\",\r\n            file: file.relativePath,\r\n            node: classDecl,\r\n            description: `Class component '${className}' detected. Modern React development favors function components with hooks for better code reuse and simpler patterns.`,\r\n            recommendation: `Consider refactoring '${className}' to a function component using hooks (useState, useEffect, etc.). This improves code readability and enables better composition with custom hooks.`,\r\n            estimatedEffort: \"medium\",\r\n            tags: [\"component\", \"class-component\", \"modernization\", \"hooks\"],\r\n          }),\r\n        );\r\n      }\r\n    }\r\n\r\n    return issues;\r\n  }\r\n\r\n  /**\r\n   * Discover React arrow function components (variable declarations with arrow functions)\r\n   */\r\n  private discoverArrowFunctionComponents(\r\n    file: FileInfo,\r\n    ast: SourceFile,\r\n  ): Issue[] {\r\n    const issues: Issue[] = [];\r\n    const variableDeclarations = this.getVariableDeclarations(ast);\r\n\r\n    for (const varDecl of variableDeclarations) {\r\n      const varName = this.getNodeName(varDecl);\r\n      if (!varName) continue;\r\n\r\n      // Cast to VariableDeclaration to access getInitializer\r\n      if (!Node.isVariableDeclaration(varDecl)) continue;\r\n      const initializer = varDecl.getInitializer();\r\n      if (!initializer || !Node.isArrowFunction(initializer)) continue;\r\n\r\n      // Check if this is a React component\r\n      if (this.isReactComponent(initializer, varName)) {\r\n        const componentInfo: ComponentInfo = {\r\n          name: varName,\r\n          type: \"arrow\",\r\n          node: varDecl,\r\n          file: file.relativePath,\r\n          isExported: this.isExported(varDecl),\r\n          hasProps: this.hasParameters(initializer),\r\n          usesHooks: this.usesReactHooks(initializer),\r\n          usesState: this.usesStateHook(initializer),\r\n        };\r\n\r\n        this.discoveredComponents.push(componentInfo);\r\n      }\r\n    }\r\n\r\n    return issues;\r\n  }\r\n\r\n  // ============================================================================\r\n  // Component Detection Helpers\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Check if a function/arrow function is a React component\r\n   * React components:\r\n   * - Start with uppercase letter (PascalCase)\r\n   * - Return JSX (contains JSX elements)\r\n   * - May use React hooks\r\n   */\r\n  private isReactComponent(node: Node, name: string): boolean {\r\n    // Check 1: Name starts with uppercase (PascalCase convention)\r\n    if (!this.isPascalCase(name)) {\r\n      return false;\r\n    }\r\n\r\n    // Check 2: Returns JSX or uses React hooks\r\n    const returnsJSX = this.returnsJSX(node);\r\n    const usesHooks = this.usesReactHooks(node);\r\n\r\n    return returnsJSX || usesHooks;\r\n  }\r\n\r\n  /**\r\n   * Check if a class is a React component\r\n   */\r\n  private isReactClassComponent(classDecl: ClassDeclaration): boolean {\r\n    const heritage = classDecl.getExtends();\r\n    if (!heritage) return false;\r\n\r\n    const heritageText = heritage.getText();\r\n\r\n    // Check if extends React.Component, React.PureComponent, Component, or PureComponent\r\n    return (\r\n      heritageText.includes(\"React.Component\") ||\r\n      heritageText.includes(\"React.PureComponent\") ||\r\n      heritageText === \"Component\" ||\r\n      heritageText === \"PureComponent\"\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Check if a name follows PascalCase convention\r\n   */\r\n  private isPascalCase(name: string): boolean {\r\n    // PascalCase: starts with uppercase, contains at least one letter\r\n    return /^[A-Z][a-zA-Z0-9]*$/.test(name) && name.length > 1;\r\n  }\r\n\r\n  /**\r\n   * Check if a function returns JSX\r\n   */\r\n  private returnsJSX(node: Node): boolean {\r\n    const text = node.getText();\r\n\r\n    // Look for JSX patterns:\r\n    // - JSX elements: <div>, <Component>\r\n    // - JSX fragments: <>, </>\r\n    // - Return statements with JSX\r\n    const jsxPatterns = [\r\n      /<[A-Z][a-zA-Z0-9]*[\\s>\\/]/, // Component tags: <MyComponent\r\n      /<[a-z][a-zA-Z0-9]*[\\s>\\/]/, // HTML tags: <div\r\n      /<>/, // Fragment opening\r\n      /<\\/>/, // Fragment closing\r\n      /return\\s*\\(/, // Return with parentheses (common for JSX)\r\n    ];\r\n\r\n    return jsxPatterns.some((pattern) => pattern.test(text));\r\n  }\r\n\r\n  /**\r\n   * Check if a function uses React hooks\r\n   */\r\n  private usesReactHooks(node: Node): boolean {\r\n    const text = node.getText();\r\n\r\n    // Common React hooks\r\n    const hookPatterns = [\r\n      /\\buse[A-Z][a-zA-Z0-9]*\\(/, // Any hook: useState, useEffect, useCustomHook\r\n      /\\buseState\\(/,\r\n      /\\buseEffect\\(/,\r\n      /\\buseContext\\(/,\r\n      /\\buseReducer\\(/,\r\n      /\\buseCallback\\(/,\r\n      /\\buseMemo\\(/,\r\n      /\\buseRef\\(/,\r\n      /\\buseImperativeHandle\\(/,\r\n      /\\buseLayoutEffect\\(/,\r\n      /\\buseDebugValue\\(/,\r\n    ];\r\n\r\n    return hookPatterns.some((pattern) => pattern.test(text));\r\n  }\r\n\r\n  /**\r\n   * Check if a function uses useState hook\r\n   */\r\n  private usesStateHook(node: Node): boolean {\r\n    const text = node.getText();\r\n    return /\\buseState\\(/.test(text);\r\n  }\r\n\r\n  /**\r\n   * Check if a function has parameters\r\n   */\r\n  private hasParameters(node: Node): boolean {\r\n    if (Node.isFunctionDeclaration(node) || Node.isArrowFunction(node)) {\r\n      return node.getParameters().length > 0;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Check if a class component has props\r\n   */\r\n  private classHasProps(classDecl: ClassDeclaration): boolean {\r\n    // Check constructor parameters\r\n    const constructors = classDecl.getConstructors();\r\n    for (const constructor of constructors) {\r\n      if (constructor.getParameters().length > 0) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    // Check if props are accessed in the class\r\n    const classText = classDecl.getText();\r\n    return classText.includes(\"this.props\");\r\n  }\r\n\r\n  /**\r\n   * Check if a class component has state\r\n   */\r\n  private classHasState(classDecl: ClassDeclaration): boolean {\r\n    const classText = classDecl.getText();\r\n\r\n    // Check for state initialization or usage\r\n    return classText.includes(\"this.state\") || classText.includes(\"setState(\");\r\n  }\r\n\r\n  // ============================================================================\r\n  // Task 7.2: Prop Drilling Detection\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Detect excessive prop drilling (props passed through more than 3 levels)\r\n   * Validates Requirements: 6.3\r\n   */\r\n  private detectPropDrilling(file: FileInfo, ast: SourceFile): Issue[] {\r\n    const issues: Issue[] = [];\r\n\r\n    // Find all JSX elements in the file\r\n    const jsxElements = this.findJSXElements(ast);\r\n\r\n    // Track prop chains through component hierarchy\r\n    const propChains = this.buildPropChains(jsxElements, ast);\r\n\r\n    // Flag chains exceeding 3 levels\r\n    for (const chain of propChains) {\r\n      if (chain.depth > 3) {\r\n        issues.push(\r\n          this.createIssue({\r\n            type: \"confusing-logic\",\r\n            severity: \"medium\",\r\n            category: \"components\",\r\n            file: file.relativePath,\r\n            node: chain.startNode,\r\n            description: `Prop drilling detected: prop '${chain.propName}' is passed through ${chain.depth} levels of components (${chain.componentPath.join(\" â†’ \")}). This makes the code harder to maintain and understand.`,\r\n            recommendation: `Consider using React Context, a state management library (Redux, Zustand), or component composition patterns to avoid passing '${chain.propName}' through ${chain.depth} levels. This will make the code more maintainable and reduce coupling between components.`,\r\n            estimatedEffort: \"medium\",\r\n            tags: [\r\n              \"component\",\r\n              \"prop-drilling\",\r\n              \"state-management\",\r\n              \"refactoring\",\r\n            ],\r\n          }),\r\n        );\r\n      }\r\n    }\r\n\r\n    return issues;\r\n  }\r\n\r\n  /**\r\n   * Find all JSX elements in the AST\r\n   */\r\n  private findJSXElements(ast: SourceFile): Node[] {\r\n    const jsxElements: Node[] = [];\r\n\r\n    const traverse = (node: Node) => {\r\n      const kind = node.getKind();\r\n\r\n      // JSX element types\r\n      if (\r\n        kind === SyntaxKind.JsxElement ||\r\n        kind === SyntaxKind.JsxSelfClosingElement ||\r\n        kind === SyntaxKind.JsxFragment\r\n      ) {\r\n        jsxElements.push(node);\r\n      }\r\n\r\n      node.forEachChild(traverse);\r\n    };\r\n\r\n    traverse(ast);\r\n    return jsxElements;\r\n  }\r\n\r\n  /**\r\n   * Build prop chains by tracking props through component hierarchy\r\n   */\r\n  private buildPropChains(jsxElements: Node[], ast: SourceFile): PropChain[] {\r\n    const chains: PropChain[] = [];\r\n\r\n    // For each component in the file, track its props\r\n    for (const component of this.discoveredComponents) {\r\n      const componentNode = component.node;\r\n      const componentName = component.name;\r\n\r\n      // Get the props parameter\r\n      const props = this.getComponentProps(componentNode);\r\n      if (!props || props.length === 0) continue;\r\n\r\n      // For each prop, track where it's passed down\r\n      for (const propName of props) {\r\n        const chain = this.trackPropThroughHierarchy(\r\n          propName,\r\n          componentName,\r\n          componentNode,\r\n          ast,\r\n          1,\r\n        );\r\n\r\n        if (chain && chain.depth > 1) {\r\n          chains.push(chain);\r\n        }\r\n      }\r\n    }\r\n\r\n    return chains;\r\n  }\r\n\r\n  /**\r\n   * Get the props from a component (parameter names)\r\n   */\r\n  private getComponentProps(componentNode: Node): string[] {\r\n    const props: string[] = [];\r\n\r\n    // Handle function components\r\n    if (\r\n      Node.isFunctionDeclaration(componentNode) ||\r\n      Node.isArrowFunction(componentNode)\r\n    ) {\r\n      const params = componentNode.getParameters();\r\n      if (params.length > 0) {\r\n        const propsParam = params[0];\r\n\r\n        // Handle destructured props: function MyComponent({ prop1, prop2 })\r\n        const binding = propsParam.getNameNode();\r\n        if (Node.isObjectBindingPattern(binding)) {\r\n          const elements = binding.getElements();\r\n          for (const element of elements) {\r\n            const name = element.getName();\r\n            if (name) {\r\n              props.push(name);\r\n            }\r\n          }\r\n        } else {\r\n          // Handle props object: function MyComponent(props)\r\n          const paramName = propsParam.getName();\r\n          if (paramName) {\r\n            // Look for props.propName usage in the component\r\n            const componentText = componentNode.getText();\r\n            const propAccessPattern = new RegExp(\r\n              `${paramName}\\\\.([a-zA-Z_$][a-zA-Z0-9_$]*)`,\r\n              \"g\",\r\n            );\r\n            let match;\r\n            while ((match = propAccessPattern.exec(componentText)) !== null) {\r\n              const propName = match[1];\r\n              if (!props.includes(propName)) {\r\n                props.push(propName);\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // Handle variable declarations with arrow functions\r\n    if (Node.isVariableDeclaration(componentNode)) {\r\n      const initializer = componentNode.getInitializer();\r\n      if (initializer && Node.isArrowFunction(initializer)) {\r\n        return this.getComponentProps(initializer);\r\n      }\r\n    }\r\n\r\n    return props;\r\n  }\r\n\r\n  /**\r\n   * Track a prop through the component hierarchy to detect drilling\r\n   */\r\n  private trackPropThroughHierarchy(\r\n    propName: string,\r\n    currentComponent: string,\r\n    componentNode: Node,\r\n    ast: SourceFile,\r\n    currentDepth: number,\r\n    visitedComponents: Set<string> = new Set(),\r\n  ): PropChain | null {\r\n    // Prevent infinite recursion\r\n    if (visitedComponents.has(currentComponent)) {\r\n      return null;\r\n    }\r\n    visitedComponents.add(currentComponent);\r\n\r\n    // Maximum depth to track (prevent excessive recursion)\r\n    if (currentDepth > 10) {\r\n      return null;\r\n    }\r\n\r\n    const componentPath = [currentComponent];\r\n    let maxDepth = currentDepth;\r\n    let deepestNode = componentNode;\r\n\r\n    // Find JSX elements within this component that pass the prop down\r\n    const jsxElements = this.findJSXElementsInNode(componentNode);\r\n\r\n    for (const jsxElement of jsxElements) {\r\n      const childComponentName = this.getJSXElementName(jsxElement);\r\n      if (!childComponentName) continue;\r\n\r\n      // Check if this JSX element passes the prop down\r\n      if (this.jsxElementPassesProp(jsxElement, propName)) {\r\n        // Find the child component definition\r\n        const childComponent = this.discoveredComponents.find(\r\n          (comp) => comp.name === childComponentName,\r\n        );\r\n\r\n        if (childComponent) {\r\n          // Recursively track the prop in the child component\r\n          const childChain = this.trackPropThroughHierarchy(\r\n            propName,\r\n            childComponentName,\r\n            childComponent.node,\r\n            ast,\r\n            currentDepth + 1,\r\n            new Set(visitedComponents),\r\n          );\r\n\r\n          if (childChain && childChain.depth > maxDepth) {\r\n            maxDepth = childChain.depth;\r\n            componentPath.push(...childChain.componentPath);\r\n            deepestNode = childChain.startNode;\r\n          }\r\n        } else {\r\n          // Child component not found in this file, assume it's passed one more level\r\n          componentPath.push(childComponentName);\r\n          maxDepth = currentDepth + 1;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (maxDepth > currentDepth) {\r\n      return {\r\n        propName,\r\n        depth: maxDepth,\r\n        componentPath,\r\n        startNode: deepestNode,\r\n      };\r\n    }\r\n\r\n    return {\r\n      propName,\r\n      depth: currentDepth,\r\n      componentPath,\r\n      startNode: componentNode,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Find JSX elements within a specific node\r\n   */\r\n  private findJSXElementsInNode(node: Node): Node[] {\r\n    const jsxElements: Node[] = [];\r\n\r\n    const traverse = (n: Node) => {\r\n      const kind = n.getKind();\r\n\r\n      if (\r\n        kind === SyntaxKind.JsxElement ||\r\n        kind === SyntaxKind.JsxSelfClosingElement\r\n      ) {\r\n        jsxElements.push(n);\r\n      }\r\n\r\n      n.forEachChild(traverse);\r\n    };\r\n\r\n    traverse(node);\r\n    return jsxElements;\r\n  }\r\n\r\n  /**\r\n   * Get the component name from a JSX element\r\n   */\r\n  private getJSXElementName(jsxElement: Node): string | null {\r\n    const text = jsxElement.getText();\r\n\r\n    // Match opening tag: <ComponentName or <ComponentName>\r\n    const match = text.match(/^<([A-Z][a-zA-Z0-9]*)/);\r\n    if (match) {\r\n      return match[1];\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Check if a JSX element passes a specific prop down\r\n   */\r\n  private jsxElementPassesProp(jsxElement: Node, propName: string): boolean {\r\n    const text = jsxElement.getText();\r\n\r\n    // Look for patterns like:\r\n    // - propName={propName}\r\n    // - propName={props.propName}\r\n    // - {...props} (spread operator)\r\n    const patterns = [\r\n      new RegExp(`\\\\b${propName}=\\\\{${propName}\\\\}`), // propName={propName}\r\n      new RegExp(`\\\\b${propName}=\\\\{props\\\\.${propName}\\\\}`), // propName={props.propName}\r\n      new RegExp(`\\\\b${propName}=\\\\{[^}]*${propName}[^}]*\\\\}`), // propName={...propName...}\r\n      /\\{\\.\\.\\.props\\}/, // {...props}\r\n      /\\{\\.\\.\\.rest\\}/, // {...rest}\r\n    ];\r\n\r\n    return patterns.some((pattern) => pattern.test(text));\r\n  }\r\n\r\n  // ============================================================================\r\n  // Public API for accessing discovered components\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Get all discovered components\r\n   */\r\n  public getDiscoveredComponents(): ComponentInfo[] {\r\n    return this.discoveredComponents;\r\n  }\r\n\r\n  /**\r\n   * Get components by type\r\n   */\r\n  public getComponentsByType(\r\n    type: \"function\" | \"class\" | \"arrow\",\r\n  ): ComponentInfo[] {\r\n    return this.discoveredComponents.filter((comp) => comp.type === type);\r\n  }\r\n\r\n  /**\r\n   * Get exported components\r\n   */\r\n  public getExportedComponents(): ComponentInfo[] {\r\n    return this.discoveredComponents.filter((comp) => comp.isExported);\r\n  }\r\n\r\n  /**\r\n   * Get components that use hooks\r\n   */\r\n  public getComponentsUsingHooks(): ComponentInfo[] {\r\n    return this.discoveredComponents.filter((comp) => comp.usesHooks);\r\n  }\r\n\r\n  /**\r\n   * Get components that use state\r\n   */\r\n  public getComponentsUsingState(): ComponentInfo[] {\r\n    return this.discoveredComponents.filter((comp) => comp.usesState);\r\n  }\r\n\r\n  /**\r\n   * Clear discovered components (useful for testing or re-analysis)\r\n   */\r\n  public clearDiscoveredComponents(): void {\r\n    this.discoveredComponents = [];\r\n  }\r\n\r\n  // ============================================================================\r\n  // Task 7.3: Component Pattern Inconsistency Detection\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Detect inconsistent component composition patterns\r\n   * Validates Requirements: 6.4\r\n   *\r\n   * Detects:\r\n   * - Inconsistent prop passing patterns (destructuring vs object)\r\n   * - Inconsistent export patterns (default vs named)\r\n   * - Inconsistent component definition styles (function vs arrow)\r\n   * - Inconsistent hook usage patterns\r\n   * - Inconsistent event handler naming\r\n   */\r\n  private detectComponentPatternInconsistencies(\r\n    file: FileInfo,\r\n    ast: SourceFile,\r\n  ): Issue[] {\r\n    const issues: Issue[] = [];\r\n\r\n    // Analyze patterns across all components in the file\r\n    const patterns = this.analyzeComponentPatterns();\r\n\r\n    // Detect inconsistent prop patterns\r\n    issues.push(...this.detectInconsistentPropPatterns(file, patterns));\r\n\r\n    // Detect inconsistent export patterns\r\n    issues.push(...this.detectInconsistentExportPatterns(file, patterns));\r\n\r\n    // Detect inconsistent component definition styles\r\n    issues.push(...this.detectInconsistentDefinitionStyles(file, patterns));\r\n\r\n    // Detect inconsistent event handler naming\r\n    issues.push(...this.detectInconsistentEventHandlerNaming(file, ast));\r\n\r\n    return issues;\r\n  }\r\n\r\n  /**\r\n   * Analyze patterns across all discovered components\r\n   */\r\n  private analyzeComponentPatterns() {\r\n    const patterns = {\r\n      propDestructuring: 0,\r\n      propObject: 0,\r\n      defaultExports: 0,\r\n      namedExports: 0,\r\n      functionDeclarations: 0,\r\n      arrowFunctions: 0,\r\n      usesTypeScript: 0,\r\n      usesJavaScript: 0,\r\n    };\r\n\r\n    for (const component of this.discoveredComponents) {\r\n      // Count prop patterns\r\n      if (this.usesPropDestructuring(component.node)) {\r\n        patterns.propDestructuring++;\r\n      } else if (component.hasProps) {\r\n        patterns.propObject++;\r\n      }\r\n\r\n      // Count export patterns\r\n      if (this.isDefaultExport(component.node)) {\r\n        patterns.defaultExports++;\r\n      } else if (component.isExported) {\r\n        patterns.namedExports++;\r\n      }\r\n\r\n      // Count definition styles\r\n      if (component.type === \"function\") {\r\n        patterns.functionDeclarations++;\r\n      } else if (component.type === \"arrow\") {\r\n        patterns.arrowFunctions++;\r\n      }\r\n    }\r\n\r\n    return patterns;\r\n  }\r\n\r\n  /**\r\n   * Detect inconsistent prop passing patterns\r\n   */\r\n  private detectInconsistentPropPatterns(\r\n    file: FileInfo,\r\n    patterns: any,\r\n  ): Issue[] {\r\n    const issues: Issue[] = [];\r\n\r\n    // If both patterns are used, flag inconsistency\r\n    if (patterns.propDestructuring > 0 && patterns.propObject > 0) {\r\n      const total = patterns.propDestructuring + patterns.propObject;\r\n      const destructuringPercent = Math.round(\r\n        (patterns.propDestructuring / total) * 100,\r\n      );\r\n\r\n      // Find components using the minority pattern\r\n      for (const component of this.discoveredComponents) {\r\n        const usesDestructuring = this.usesPropDestructuring(component.node);\r\n        const isMinorityPattern =\r\n          (usesDestructuring && destructuringPercent < 50) ||\r\n          (!usesDestructuring &&\r\n            component.hasProps &&\r\n            destructuringPercent >= 50);\r\n\r\n        if (isMinorityPattern) {\r\n          const preferredPattern =\r\n            destructuringPercent >= 50 ? \"destructuring\" : \"object\";\r\n          const currentPattern = usesDestructuring ? \"destructuring\" : \"object\";\r\n\r\n          issues.push(\r\n            this.createIssue({\r\n              type: \"inconsistent-pattern\",\r\n              severity: \"low\",\r\n              category: \"components\",\r\n              file: file.relativePath,\r\n              node: component.node,\r\n              description: `Component '${component.name}' uses ${currentPattern} for props, but ${patterns.propDestructuring} components use destructuring and ${patterns.propObject} use object props. This inconsistency makes the codebase harder to understand.`,\r\n              recommendation: `Consider using ${preferredPattern} pattern for props consistently across all components. This improves code readability and maintainability.`,\r\n              estimatedEffort: \"trivial\",\r\n              tags: [\r\n                \"component\",\r\n                \"inconsistent-pattern\",\r\n                \"props\",\r\n                \"code-style\",\r\n              ],\r\n            }),\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    return issues;\r\n  }\r\n\r\n  /**\r\n   * Detect inconsistent export patterns\r\n   */\r\n  private detectInconsistentExportPatterns(\r\n    file: FileInfo,\r\n    patterns: any,\r\n  ): Issue[] {\r\n    const issues: Issue[] = [];\r\n\r\n    // If both export patterns are used, flag inconsistency\r\n    if (patterns.defaultExports > 0 && patterns.namedExports > 0) {\r\n      const total = patterns.defaultExports + patterns.namedExports;\r\n      const defaultPercent = Math.round(\r\n        (patterns.defaultExports / total) * 100,\r\n      );\r\n\r\n      // Find components using the minority pattern\r\n      for (const component of this.discoveredComponents) {\r\n        const isDefault = this.isDefaultExport(component.node);\r\n        const isMinorityPattern =\r\n          (isDefault && defaultPercent < 50) ||\r\n          (component.isExported && !isDefault && defaultPercent >= 50);\r\n\r\n        if (isMinorityPattern) {\r\n          const preferredPattern = defaultPercent >= 50 ? \"default\" : \"named\";\r\n          const currentPattern = isDefault ? \"default\" : \"named\";\r\n\r\n          issues.push(\r\n            this.createIssue({\r\n              type: \"inconsistent-pattern\",\r\n              severity: \"low\",\r\n              category: \"components\",\r\n              file: file.relativePath,\r\n              node: component.node,\r\n              description: `Component '${component.name}' uses ${currentPattern} export, but ${patterns.defaultExports} components use default exports and ${patterns.namedExports} use named exports. This inconsistency can confuse developers.`,\r\n              recommendation: `Consider using ${preferredPattern} exports consistently across all components. This makes imports more predictable and consistent.`,\r\n              estimatedEffort: \"trivial\",\r\n              tags: [\r\n                \"component\",\r\n                \"inconsistent-pattern\",\r\n                \"exports\",\r\n                \"code-style\",\r\n              ],\r\n            }),\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    return issues;\r\n  }\r\n\r\n  /**\r\n   * Detect inconsistent component definition styles\r\n   */\r\n  private detectInconsistentDefinitionStyles(\r\n    file: FileInfo,\r\n    patterns: any,\r\n  ): Issue[] {\r\n    const issues: Issue[] = [];\r\n\r\n    // If both function and arrow styles are used, flag inconsistency\r\n    if (patterns.functionDeclarations > 0 && patterns.arrowFunctions > 0) {\r\n      const total = patterns.functionDeclarations + patterns.arrowFunctions;\r\n      const functionPercent = Math.round(\r\n        (patterns.functionDeclarations / total) * 100,\r\n      );\r\n\r\n      // Find components using the minority pattern\r\n      for (const component of this.discoveredComponents) {\r\n        if (component.type === \"class\") continue; // Skip class components\r\n\r\n        const isFunction = component.type === \"function\";\r\n        const isMinorityPattern =\r\n          (isFunction && functionPercent < 50) ||\r\n          (component.type === \"arrow\" && functionPercent >= 50);\r\n\r\n        if (isMinorityPattern) {\r\n          const preferredPattern =\r\n            functionPercent >= 50 ? \"function declaration\" : \"arrow function\";\r\n          const currentPattern = isFunction\r\n            ? \"function declaration\"\r\n            : \"arrow function\";\r\n\r\n          issues.push(\r\n            this.createIssue({\r\n              type: \"inconsistent-pattern\",\r\n              severity: \"low\",\r\n              category: \"components\",\r\n              file: file.relativePath,\r\n              node: component.node,\r\n              description: `Component '${component.name}' is defined as ${currentPattern}, but ${patterns.functionDeclarations} components use function declarations and ${patterns.arrowFunctions} use arrow functions. This inconsistency affects code style uniformity.`,\r\n              recommendation: `Consider using ${preferredPattern} consistently for all function components. This creates a more uniform codebase.`,\r\n              estimatedEffort: \"trivial\",\r\n              tags: [\r\n                \"component\",\r\n                \"inconsistent-pattern\",\r\n                \"definition-style\",\r\n                \"code-style\",\r\n              ],\r\n            }),\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    return issues;\r\n  }\r\n\r\n  /**\r\n   * Detect inconsistent event handler naming patterns\r\n   */\r\n  private detectInconsistentEventHandlerNaming(\r\n    file: FileInfo,\r\n    ast: SourceFile,\r\n  ): Issue[] {\r\n    const issues: Issue[] = [];\r\n\r\n    // Track event handler naming patterns\r\n    const handlerPatterns = {\r\n      handlePrefix: 0, // handleClick, handleSubmit\r\n      onPrefix: 0, // onClick, onSubmit\r\n      other: 0, // click, submit, doSomething\r\n    };\r\n\r\n    const inconsistentHandlers: Array<{\r\n      name: string;\r\n      node: Node;\r\n      pattern: string;\r\n    }> = [];\r\n\r\n    for (const component of this.discoveredComponents) {\r\n      const handlers = this.findEventHandlers(component.node);\r\n\r\n      for (const handler of handlers) {\r\n        if (handler.name.startsWith(\"handle\")) {\r\n          handlerPatterns.handlePrefix++;\r\n          inconsistentHandlers.push({ ...handler, pattern: \"handle\" });\r\n        } else if (handler.name.startsWith(\"on\")) {\r\n          handlerPatterns.onPrefix++;\r\n          inconsistentHandlers.push({ ...handler, pattern: \"on\" });\r\n        } else {\r\n          handlerPatterns.other++;\r\n          inconsistentHandlers.push({ ...handler, pattern: \"other\" });\r\n        }\r\n      }\r\n    }\r\n\r\n    // If multiple patterns are used, flag inconsistency\r\n    const patternsUsed = [\r\n      handlerPatterns.handlePrefix > 0,\r\n      handlerPatterns.onPrefix > 0,\r\n      handlerPatterns.other > 0,\r\n    ].filter(Boolean).length;\r\n\r\n    if (patternsUsed > 1) {\r\n      const total =\r\n        handlerPatterns.handlePrefix +\r\n        handlerPatterns.onPrefix +\r\n        handlerPatterns.other;\r\n      const dominantPattern =\r\n        handlerPatterns.handlePrefix > handlerPatterns.onPrefix &&\r\n        handlerPatterns.handlePrefix > handlerPatterns.other\r\n          ? \"handle\"\r\n          : handlerPatterns.onPrefix > handlerPatterns.other\r\n            ? \"on\"\r\n            : \"other\";\r\n\r\n      // Flag handlers using minority patterns\r\n      for (const handler of inconsistentHandlers) {\r\n        if (handler.pattern !== dominantPattern) {\r\n          const preferredExample =\r\n            dominantPattern === \"handle\"\r\n              ? \"handleClick\"\r\n              : dominantPattern === \"on\"\r\n                ? \"onClick\"\r\n                : \"descriptive names\";\r\n\r\n          issues.push(\r\n            this.createIssue({\r\n              type: \"inconsistent-pattern\",\r\n              severity: \"low\",\r\n              category: \"components\",\r\n              file: file.relativePath,\r\n              node: handler.node,\r\n              description: `Event handler '${handler.name}' uses '${handler.pattern}' prefix, but the codebase has ${handlerPatterns.handlePrefix} 'handle' handlers, ${handlerPatterns.onPrefix} 'on' handlers, and ${handlerPatterns.other} other patterns. This inconsistency makes the code less predictable.`,\r\n              recommendation: `Consider using '${dominantPattern}' prefix consistently for event handlers (e.g., ${preferredExample}). This improves code consistency and makes event handlers easier to identify.`,\r\n              estimatedEffort: \"trivial\",\r\n              tags: [\r\n                \"component\",\r\n                \"inconsistent-pattern\",\r\n                \"event-handlers\",\r\n                \"naming\",\r\n              ],\r\n            }),\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    return issues;\r\n  }\r\n\r\n  /**\r\n   * Find event handler functions in a component\r\n   */\r\n  private findEventHandlers(node: Node): Array<{ name: string; node: Node }> {\r\n    const handlers: Array<{ name: string; node: Node }> = [];\r\n    const text = node.getText();\r\n\r\n    // Look for common event handler patterns in JSX\r\n    const eventAttributes = [\r\n      \"onClick\",\r\n      \"onChange\",\r\n      \"onSubmit\",\r\n      \"onFocus\",\r\n      \"onBlur\",\r\n      \"onKeyDown\",\r\n      \"onKeyUp\",\r\n      \"onKeyPress\",\r\n      \"onMouseEnter\",\r\n      \"onMouseLeave\",\r\n      \"onMouseDown\",\r\n      \"onMouseUp\",\r\n      \"onInput\",\r\n      \"onScroll\",\r\n      \"onLoad\",\r\n    ];\r\n\r\n    for (const eventAttr of eventAttributes) {\r\n      // Match patterns like onClick={handleClick} or onClick={onClickHandler}\r\n      const pattern = new RegExp(\r\n        `${eventAttr}=\\\\{([a-zA-Z_$][a-zA-Z0-9_$]*)\\\\}`,\r\n        \"g\",\r\n      );\r\n      let match;\r\n\r\n      while ((match = pattern.exec(text)) !== null) {\r\n        const handlerName = match[1];\r\n\r\n        // Find the actual function definition\r\n        const handlerNode = this.findFunctionByName(node, handlerName);\r\n        if (handlerNode) {\r\n          handlers.push({ name: handlerName, node: handlerNode });\r\n        }\r\n      }\r\n    }\r\n\r\n    return handlers;\r\n  }\r\n\r\n  /**\r\n   * Find a function definition by name within a node\r\n   */\r\n  private findFunctionByName(node: Node, name: string): Node | null {\r\n    let foundNode: Node | null = null;\r\n\r\n    const traverse = (n: Node) => {\r\n      if (foundNode) return;\r\n\r\n      // Check function declarations\r\n      if (Node.isFunctionDeclaration(n)) {\r\n        if (n.getName() === name) {\r\n          foundNode = n;\r\n          return;\r\n        }\r\n      }\r\n\r\n      // Check variable declarations with arrow functions\r\n      if (Node.isVariableDeclaration(n)) {\r\n        if (this.getNodeName(n) === name) {\r\n          foundNode = n;\r\n          return;\r\n        }\r\n      }\r\n\r\n      n.forEachChild(traverse);\r\n    };\r\n\r\n    traverse(node);\r\n    return foundNode;\r\n  }\r\n\r\n  // ============================================================================\r\n  // Task 7.3: Duplicate Component Logic Detection\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Detect duplicate component logic across components\r\n   * Validates Requirements: 6.5\r\n   *\r\n   * Detects:\r\n   * - Duplicate validation logic\r\n   * - Duplicate data transformation logic\r\n   * - Duplicate effect patterns\r\n   * - Duplicate custom hook patterns\r\n   * - Similar component structures\r\n   */\r\n  private detectDuplicateComponentLogic(\r\n    file: FileInfo,\r\n    ast: SourceFile,\r\n  ): Issue[] {\r\n    const issues: Issue[] = [];\r\n\r\n    // Detect duplicate validation logic\r\n    issues.push(...this.detectDuplicateValidation(file));\r\n\r\n    // Detect duplicate useEffect patterns\r\n    issues.push(...this.detectDuplicateEffects(file));\r\n\r\n    // Detect duplicate data transformations\r\n    issues.push(...this.detectDuplicateTransformations(file));\r\n\r\n    // Detect similar component structures\r\n    issues.push(...this.detectSimilarComponentStructures(file));\r\n\r\n    return issues;\r\n  }\r\n\r\n  /**\r\n   * Detect duplicate validation logic across components\r\n   */\r\n  private detectDuplicateValidation(file: FileInfo): Issue[] {\r\n    const issues: Issue[] = [];\r\n    const validationPatterns = new Map<\r\n      string,\r\n      Array<{ component: ComponentInfo; node: Node }>\r\n    >();\r\n\r\n    for (const component of this.discoveredComponents) {\r\n      const validations = this.extractValidationLogic(component.node);\r\n\r\n      for (const validation of validations) {\r\n        const pattern = this.normalizeCode(validation.code);\r\n\r\n        if (!validationPatterns.has(pattern)) {\r\n          validationPatterns.set(pattern, []);\r\n        }\r\n\r\n        validationPatterns.get(pattern)!.push({\r\n          component,\r\n          node: validation.node,\r\n        });\r\n      }\r\n    }\r\n\r\n    // Flag patterns that appear in multiple components\r\n    for (const [pattern, occurrences] of validationPatterns.entries()) {\r\n      if (occurrences.length > 1) {\r\n        const componentNames = occurrences\r\n          .map((o) => o.component.name)\r\n          .join(\", \");\r\n\r\n        for (const occurrence of occurrences) {\r\n          issues.push(\r\n            this.createIssue({\r\n              type: \"code-duplication\",\r\n              severity: \"medium\",\r\n              category: \"components\",\r\n              file: file.relativePath,\r\n              node: occurrence.node,\r\n              description: `Duplicate validation logic found in component '${occurrence.component.name}'. This same validation appears in ${occurrences.length} components: ${componentNames}. Duplicated validation logic increases maintenance burden.`,\r\n              recommendation: `Extract this validation logic into a shared utility function or custom hook. This will make the validation logic reusable and easier to maintain. Consider creating a validation utility in a shared location.`,\r\n              estimatedEffort: \"small\",\r\n              tags: [\r\n                \"component\",\r\n                \"code-duplication\",\r\n                \"validation\",\r\n                \"refactoring\",\r\n              ],\r\n            }),\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    return issues;\r\n  }\r\n\r\n  /**\r\n   * Extract validation logic from a component\r\n   */\r\n  private extractValidationLogic(\r\n    node: Node,\r\n  ): Array<{ code: string; node: Node }> {\r\n    const validations: Array<{ code: string; node: Node }> = [];\r\n    const text = node.getText();\r\n\r\n    // Look for common validation patterns\r\n    const validationKeywords = [\r\n      \"validate\",\r\n      \"isValid\",\r\n      \"check\",\r\n      \"verify\",\r\n      \"test\",\r\n      \"required\",\r\n      \"optional\",\r\n      \"min\",\r\n      \"max\",\r\n      \"pattern\",\r\n      \"email\",\r\n      \"phone\",\r\n      \"url\",\r\n      \"number\",\r\n      \"string\",\r\n    ];\r\n\r\n    const traverse = (n: Node) => {\r\n      // Look for if statements with validation logic\r\n      if (Node.isIfStatement(n)) {\r\n        const condition = n.getExpression().getText();\r\n\r\n        if (\r\n          validationKeywords.some((keyword) =>\r\n            condition.toLowerCase().includes(keyword),\r\n          )\r\n        ) {\r\n          validations.push({\r\n            code: n.getText(),\r\n            node: n,\r\n          });\r\n        }\r\n      }\r\n\r\n      // Look for validation functions\r\n      if (Node.isFunctionDeclaration(n) || Node.isArrowFunction(n)) {\r\n        const funcText = n.getText();\r\n        const funcName = Node.isFunctionDeclaration(n) ? n.getName() : \"\";\r\n\r\n        if (\r\n          validationKeywords.some(\r\n            (keyword) =>\r\n              funcName?.toLowerCase().includes(keyword) ||\r\n              funcText.toLowerCase().includes(keyword),\r\n          )\r\n        ) {\r\n          validations.push({\r\n            code: funcText,\r\n            node: n,\r\n          });\r\n        }\r\n      }\r\n\r\n      n.forEachChild(traverse);\r\n    };\r\n\r\n    traverse(node);\r\n    return validations;\r\n  }\r\n\r\n  /**\r\n   * Detect duplicate useEffect patterns\r\n   */\r\n  private detectDuplicateEffects(file: FileInfo): Issue[] {\r\n    const issues: Issue[] = [];\r\n    const effectPatterns = new Map<\r\n      string,\r\n      Array<{ component: ComponentInfo; node: Node }>\r\n    >();\r\n\r\n    for (const component of this.discoveredComponents) {\r\n      const effects = this.extractEffects(component.node);\r\n\r\n      for (const effect of effects) {\r\n        const pattern = this.normalizeCode(effect.code);\r\n\r\n        if (!effectPatterns.has(pattern)) {\r\n          effectPatterns.set(pattern, []);\r\n        }\r\n\r\n        effectPatterns.get(pattern)!.push({\r\n          component,\r\n          node: effect.node,\r\n        });\r\n      }\r\n    }\r\n\r\n    // Flag patterns that appear in multiple components\r\n    for (const [pattern, occurrences] of effectPatterns.entries()) {\r\n      if (occurrences.length > 1) {\r\n        const componentNames = occurrences\r\n          .map((o) => o.component.name)\r\n          .join(\", \");\r\n\r\n        for (const occurrence of occurrences) {\r\n          issues.push(\r\n            this.createIssue({\r\n              type: \"code-duplication\",\r\n              severity: \"medium\",\r\n              category: \"components\",\r\n              file: file.relativePath,\r\n              node: occurrence.node,\r\n              description: `Duplicate useEffect logic found in component '${occurrence.component.name}'. This same effect appears in ${occurrences.length} components: ${componentNames}. Duplicated effects increase maintenance burden.`,\r\n              recommendation: `Extract this effect logic into a custom hook. This will make the effect reusable and easier to maintain. Consider creating a custom hook like 'use[DescriptiveName]' in a shared hooks directory.`,\r\n              estimatedEffort: \"small\",\r\n              tags: [\r\n                \"component\",\r\n                \"code-duplication\",\r\n                \"hooks\",\r\n                \"useEffect\",\r\n                \"refactoring\",\r\n              ],\r\n            }),\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    return issues;\r\n  }\r\n\r\n  /**\r\n   * Extract useEffect calls from a component\r\n   */\r\n  private extractEffects(node: Node): Array<{ code: string; node: Node }> {\r\n    const effects: Array<{ code: string; node: Node }> = [];\r\n    const text = node.getText();\r\n\r\n    // Find useEffect calls\r\n    const effectPattern = /useEffect\\s*\\(/g;\r\n    let match;\r\n\r\n    while ((match = effectPattern.exec(text)) !== null) {\r\n      // Try to find the actual call expression node\r\n      const traverse = (n: Node) => {\r\n        if (Node.isCallExpression(n)) {\r\n          const expr = n.getExpression();\r\n          if (expr.getText() === \"useEffect\") {\r\n            effects.push({\r\n              code: n.getText(),\r\n              node: n,\r\n            });\r\n          }\r\n        }\r\n        n.forEachChild(traverse);\r\n      };\r\n\r\n      traverse(node);\r\n    }\r\n\r\n    return effects;\r\n  }\r\n\r\n  /**\r\n   * Detect duplicate data transformation logic\r\n   */\r\n  private detectDuplicateTransformations(file: FileInfo): Issue[] {\r\n    const issues: Issue[] = [];\r\n    const transformPatterns = new Map<\r\n      string,\r\n      Array<{ component: ComponentInfo; node: Node }>\r\n    >();\r\n\r\n    for (const component of this.discoveredComponents) {\r\n      const transforms = this.extractTransformations(component.node);\r\n\r\n      for (const transform of transforms) {\r\n        const pattern = this.normalizeCode(transform.code);\r\n\r\n        if (!transformPatterns.has(pattern)) {\r\n          transformPatterns.set(pattern, []);\r\n        }\r\n\r\n        transformPatterns.get(pattern)!.push({\r\n          component,\r\n          node: transform.node,\r\n        });\r\n      }\r\n    }\r\n\r\n    // Flag patterns that appear in multiple components\r\n    for (const [pattern, occurrences] of transformPatterns.entries()) {\r\n      if (occurrences.length > 1) {\r\n        const componentNames = occurrences\r\n          .map((o) => o.component.name)\r\n          .join(\", \");\r\n\r\n        for (const occurrence of occurrences) {\r\n          issues.push(\r\n            this.createIssue({\r\n              type: \"code-duplication\",\r\n              severity: \"medium\",\r\n              category: \"components\",\r\n              file: file.relativePath,\r\n              node: occurrence.node,\r\n              description: `Duplicate data transformation logic found in component '${occurrence.component.name}'. This same transformation appears in ${occurrences.length} components: ${componentNames}. Duplicated transformations increase maintenance burden.`,\r\n              recommendation: `Extract this transformation logic into a shared utility function. This will make the transformation reusable and easier to maintain. Consider creating a utility function in a shared location.`,\r\n              estimatedEffort: \"small\",\r\n              tags: [\r\n                \"component\",\r\n                \"code-duplication\",\r\n                \"transformation\",\r\n                \"refactoring\",\r\n              ],\r\n            }),\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    return issues;\r\n  }\r\n\r\n  /**\r\n   * Extract data transformation logic from a component\r\n   */\r\n  private extractTransformations(\r\n    node: Node,\r\n  ): Array<{ code: string; node: Node }> {\r\n    const transformations: Array<{ code: string; node: Node }> = [];\r\n\r\n    const traverse = (n: Node) => {\r\n      // Look for array methods (map, filter, reduce, etc.)\r\n      if (Node.isCallExpression(n)) {\r\n        const expr = n.getExpression();\r\n        const exprText = expr.getText();\r\n\r\n        if (\r\n          exprText.endsWith(\".map\") ||\r\n          exprText.endsWith(\".filter\") ||\r\n          exprText.endsWith(\".reduce\") ||\r\n          exprText.endsWith(\".sort\") ||\r\n          exprText.endsWith(\".find\") ||\r\n          exprText.endsWith(\".findIndex\")\r\n        ) {\r\n          transformations.push({\r\n            code: n.getText(),\r\n            node: n,\r\n          });\r\n        }\r\n      }\r\n\r\n      n.forEachChild(traverse);\r\n    };\r\n\r\n    traverse(node);\r\n    return transformations;\r\n  }\r\n\r\n  /**\r\n   * Detect similar component structures (potential for abstraction)\r\n   */\r\n  private detectSimilarComponentStructures(file: FileInfo): Issue[] {\r\n    const issues: Issue[] = [];\r\n\r\n    // Compare components pairwise for structural similarity\r\n    for (let i = 0; i < this.discoveredComponents.length; i++) {\r\n      for (let j = i + 1; j < this.discoveredComponents.length; j++) {\r\n        const comp1 = this.discoveredComponents[i];\r\n        const comp2 = this.discoveredComponents[j];\r\n\r\n        const similarity = this.calculateStructuralSimilarity(comp1, comp2);\r\n\r\n        // If components are very similar (>70% similar), flag for potential abstraction\r\n        if (similarity > 0.7) {\r\n          issues.push(\r\n            this.createIssue({\r\n              type: \"code-duplication\",\r\n              severity: \"medium\",\r\n              category: \"components\",\r\n              file: file.relativePath,\r\n              node: comp1.node,\r\n              description: `Components '${comp1.name}' and '${comp2.name}' have very similar structures (${Math.round(similarity * 100)}% similar). This suggests they could be abstracted into a single reusable component.`,\r\n              recommendation: `Consider creating a single component that accepts configuration props to handle both use cases. This reduces code duplication and makes the codebase more maintainable. Look for common patterns and extract them into a shared component.`,\r\n              estimatedEffort: \"medium\",\r\n              tags: [\r\n                \"component\",\r\n                \"code-duplication\",\r\n                \"abstraction\",\r\n                \"refactoring\",\r\n              ],\r\n            }),\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    return issues;\r\n  }\r\n\r\n  /**\r\n   * Calculate structural similarity between two components\r\n   */\r\n  private calculateStructuralSimilarity(\r\n    comp1: ComponentInfo,\r\n    comp2: ComponentInfo,\r\n  ): number {\r\n    let similarityScore = 0;\r\n    let totalChecks = 0;\r\n\r\n    // Compare component types\r\n    totalChecks++;\r\n    if (comp1.type === comp2.type) {\r\n      similarityScore++;\r\n    }\r\n\r\n    // Compare hook usage\r\n    totalChecks++;\r\n    if (comp1.usesHooks === comp2.usesHooks) {\r\n      similarityScore++;\r\n    }\r\n\r\n    // Compare state usage\r\n    totalChecks++;\r\n    if (comp1.usesState === comp2.usesState) {\r\n      similarityScore++;\r\n    }\r\n\r\n    // Compare props usage\r\n    totalChecks++;\r\n    if (comp1.hasProps === comp2.hasProps) {\r\n      similarityScore++;\r\n    }\r\n\r\n    // Compare code structure (simplified - count similar patterns)\r\n    const text1 = comp1.node.getText();\r\n    const text2 = comp2.node.getText();\r\n\r\n    // Count common patterns\r\n    const patterns = [\r\n      /useEffect/g,\r\n      /useState/g,\r\n      /useCallback/g,\r\n      /useMemo/g,\r\n      /return\\s*\\(/g,\r\n      /onClick/g,\r\n      /onChange/g,\r\n      /className/g,\r\n    ];\r\n\r\n    for (const pattern of patterns) {\r\n      totalChecks++;\r\n      const count1 = (text1.match(pattern) || []).length;\r\n      const count2 = (text2.match(pattern) || []).length;\r\n\r\n      if (count1 > 0 && count2 > 0) {\r\n        // Both use this pattern\r\n        const ratio = Math.min(count1, count2) / Math.max(count1, count2);\r\n        similarityScore += ratio;\r\n      }\r\n    }\r\n\r\n    return similarityScore / totalChecks;\r\n  }\r\n\r\n  /**\r\n   * Normalize code for comparison (remove whitespace, comments, etc.)\r\n   */\r\n  private normalizeCode(code: string): string {\r\n    return code\r\n      .replace(/\\/\\*[\\s\\S]*?\\*\\//g, \"\") // Remove block comments\r\n      .replace(/\\/\\/.*/g, \"\") // Remove line comments\r\n      .replace(/\\s+/g, \" \") // Normalize whitespace\r\n      .trim();\r\n  }\r\n\r\n  // ============================================================================\r\n  // Helper Methods for Pattern Detection\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Check if a component uses prop destructuring\r\n   */\r\n  private usesPropDestructuring(node: Node): boolean {\r\n    if (Node.isFunctionDeclaration(node) || Node.isArrowFunction(node)) {\r\n      const params = node.getParameters();\r\n      if (params.length > 0) {\r\n        const binding = params[0].getNameNode();\r\n        return Node.isObjectBindingPattern(binding);\r\n      }\r\n    }\r\n\r\n    if (Node.isVariableDeclaration(node)) {\r\n      const initializer = node.getInitializer();\r\n      if (initializer && Node.isArrowFunction(initializer)) {\r\n        return this.usesPropDestructuring(initializer);\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Check if a component uses default export\r\n   */\r\n  private isDefaultExport(node: Node): boolean {\r\n    const parent = node.getParent();\r\n\r\n    // Check if this is a default export declaration\r\n    if (parent && Node.isExportAssignment(parent)) {\r\n      return true;\r\n    }\r\n\r\n    // Check if there's a separate default export statement\r\n    const sourceFile = node.getSourceFile();\r\n    const defaultExports = sourceFile.getExportAssignments();\r\n\r\n    for (const exportAssignment of defaultExports) {\r\n      const expr = exportAssignment.getExpression();\r\n      const nodeName = this.getNodeName(node);\r\n\r\n      if (nodeName && expr.getText() === nodeName) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    // Check for \"export default\" syntax\r\n    const text = node.getText();\r\n    const fullText = node.getFullText();\r\n\r\n    return (\r\n      fullText.includes(\"export default\") || text.startsWith(\"export default\")\r\n    );\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\Development\\aluminify\\codebase-cleanup\\src\\analyzers\\pattern-analyzer.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":322,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":322,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9497,9500],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9497,9500],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":343,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":343,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10041,10044],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10041,10044],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":348,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":348,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10222,10225],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10222,10225],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":357,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":357,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10614,10617],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10614,10617],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":358,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":358,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10678,10681],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10678,10681],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":359,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":359,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10736,10739],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10736,10739],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Abstract base class for all pattern analyzers\r\n * Provides common utilities for AST traversal and issue creation\r\n */\r\n\r\nimport { SourceFile, Node, SyntaxKind } from 'ts-morph';\r\nimport { randomUUID } from 'crypto';\r\nimport type {\r\n  PatternAnalyzer,\r\n  FileInfo,\r\n  Issue,\r\n  IssueType,\r\n  IssueCategory,\r\n  Severity,\r\n  EffortLevel,\r\n  CodeLocation,\r\n  FileCategory,\r\n} from '../types.js';\r\n\r\n/**\r\n * Abstract base class that all pattern analyzers must extend\r\n */\r\nexport abstract class BasePatternAnalyzer implements PatternAnalyzer {\r\n  /**\r\n   * Name of the analyzer (must be implemented by subclasses)\r\n   */\r\n  abstract readonly name: string;\r\n\r\n  /**\r\n   * Analyze a file and return detected issues\r\n   * @param file File information\r\n   * @param ast Parsed AST of the file\r\n   * @returns Array of detected issues\r\n   */\r\n  abstract analyze(file: FileInfo, ast: SourceFile): Promise<Issue[]>;\r\n\r\n  /**\r\n   * Get the file types this analyzer supports\r\n   * @returns Array of supported file categories\r\n   */\r\n  abstract getSupportedFileTypes(): FileCategory[];\r\n\r\n  // ============================================================================\r\n  // Issue Creation Helpers\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Create an issue with proper location tracking\r\n   * @param params Issue parameters\r\n   * @returns Complete Issue object\r\n   */\r\n  protected createIssue(params: {\r\n    type: IssueType;\r\n    severity: Severity;\r\n    category: IssueCategory;\r\n    file: string;\r\n    node: Node;\r\n    description: string;\r\n    recommendation: string;\r\n    estimatedEffort: EffortLevel;\r\n    tags?: string[];\r\n  }): Issue {\r\n    const location = this.getNodeLocation(params.node);\r\n    const codeSnippet = this.getCodeSnippet(params.node);\r\n\r\n    return {\r\n      id: randomUUID(),\r\n      type: params.type,\r\n      severity: params.severity,\r\n      category: params.category,\r\n      file: params.file,\r\n      location,\r\n      description: params.description,\r\n      codeSnippet,\r\n      recommendation: params.recommendation,\r\n      estimatedEffort: params.estimatedEffort,\r\n      tags: params.tags || [],\r\n      detectedBy: this.name,\r\n      detectedAt: new Date(),\r\n      relatedIssues: [],\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get the location of a node in the source file\r\n   * @param node AST node\r\n   * @returns Code location with line and column numbers\r\n   */\r\n  protected getNodeLocation(node: Node): CodeLocation {\r\n    const sourceFile = node.getSourceFile();\r\n    const start = node.getStart();\r\n    const end = node.getEnd();\r\n\r\n    const startLineAndColumn = sourceFile.getLineAndColumnAtPos(start);\r\n    const endLineAndColumn = sourceFile.getLineAndColumnAtPos(end);\r\n\r\n    return {\r\n      startLine: startLineAndColumn.line,\r\n      endLine: endLineAndColumn.line,\r\n      startColumn: startLineAndColumn.column,\r\n      endColumn: endLineAndColumn.column,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get a code snippet from a node\r\n   * @param node AST node\r\n   * @param maxLength Maximum length of snippet (default: 200)\r\n   * @returns Code snippet as string\r\n   */\r\n  protected getCodeSnippet(node: Node, maxLength: number = 200): string {\r\n    const text = node.getText();\r\n    if (text.length <= maxLength) {\r\n      return text;\r\n    }\r\n    return text.substring(0, maxLength) + '...';\r\n  }\r\n\r\n  // ============================================================================\r\n  // AST Traversal Utilities\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Find all nodes of a specific kind in the AST\r\n   * @param ast Source file AST\r\n   * @param kind Syntax kind to search for\r\n   * @returns Array of matching nodes\r\n   */\r\n  protected findNodesByKind(ast: SourceFile, kind: SyntaxKind): Node[] {\r\n    const nodes: Node[] = [];\r\n    \r\n    const traverse = (node: Node) => {\r\n      if (node.getKind() === kind) {\r\n        nodes.push(node);\r\n      }\r\n      node.forEachChild(traverse);\r\n    };\r\n\r\n    traverse(ast);\r\n    return nodes;\r\n  }\r\n\r\n  /**\r\n   * Find all nodes matching a predicate function\r\n   * @param ast Source file AST\r\n   * @param predicate Function to test each node\r\n   * @returns Array of matching nodes\r\n   */\r\n  protected findNodes(ast: SourceFile, predicate: (node: Node) => boolean): Node[] {\r\n    const nodes: Node[] = [];\r\n    \r\n    const traverse = (node: Node) => {\r\n      if (predicate(node)) {\r\n        nodes.push(node);\r\n      }\r\n      node.forEachChild(traverse);\r\n    };\r\n\r\n    traverse(ast);\r\n    return nodes;\r\n  }\r\n\r\n  /**\r\n   * Get all function declarations in the AST\r\n   * @param ast Source file AST\r\n   * @returns Array of function declaration nodes\r\n   */\r\n  protected getFunctionDeclarations(ast: SourceFile): Node[] {\r\n    return this.findNodesByKind(ast, SyntaxKind.FunctionDeclaration);\r\n  }\r\n\r\n  /**\r\n   * Get all arrow functions in the AST\r\n   * @param ast Source file AST\r\n   * @returns Array of arrow function nodes\r\n   */\r\n  protected getArrowFunctions(ast: SourceFile): Node[] {\r\n    return this.findNodesByKind(ast, SyntaxKind.ArrowFunction);\r\n  }\r\n\r\n  /**\r\n   * Get all function expressions in the AST\r\n   * @param ast Source file AST\r\n   * @returns Array of function expression nodes\r\n   */\r\n  protected getFunctionExpressions(ast: SourceFile): Node[] {\r\n    return this.findNodesByKind(ast, SyntaxKind.FunctionExpression);\r\n  }\r\n\r\n  /**\r\n   * Get all method declarations in the AST\r\n   * @param ast Source file AST\r\n   * @returns Array of method declaration nodes\r\n   */\r\n  protected getMethodDeclarations(ast: SourceFile): Node[] {\r\n    return this.findNodesByKind(ast, SyntaxKind.MethodDeclaration);\r\n  }\r\n\r\n  /**\r\n   * Get all class declarations in the AST\r\n   * @param ast Source file AST\r\n   * @returns Array of class declaration nodes\r\n   */\r\n  protected getClassDeclarations(ast: SourceFile): Node[] {\r\n    return this.findNodesByKind(ast, SyntaxKind.ClassDeclaration);\r\n  }\r\n\r\n  /**\r\n   * Get all interface declarations in the AST\r\n   * @param ast Source file AST\r\n   * @returns Array of interface declaration nodes\r\n   */\r\n  protected getInterfaceDeclarations(ast: SourceFile): Node[] {\r\n    return this.findNodesByKind(ast, SyntaxKind.InterfaceDeclaration);\r\n  }\r\n\r\n  /**\r\n   * Get all type alias declarations in the AST\r\n   * @param ast Source file AST\r\n   * @returns Array of type alias nodes\r\n   */\r\n  protected getTypeAliases(ast: SourceFile): Node[] {\r\n    return this.findNodesByKind(ast, SyntaxKind.TypeAliasDeclaration);\r\n  }\r\n\r\n  /**\r\n   * Get all import declarations in the AST\r\n   * @param ast Source file AST\r\n   * @returns Array of import declaration nodes\r\n   */\r\n  protected getImportDeclarations(ast: SourceFile): Node[] {\r\n    return this.findNodesByKind(ast, SyntaxKind.ImportDeclaration);\r\n  }\r\n\r\n  /**\r\n   * Get all export declarations in the AST\r\n   * @param ast Source file AST\r\n   * @returns Array of export declaration nodes\r\n   */\r\n  protected getExportDeclarations(ast: SourceFile): Node[] {\r\n    return this.findNodesByKind(ast, SyntaxKind.ExportDeclaration);\r\n  }\r\n\r\n  /**\r\n   * Get all variable declarations in the AST\r\n   * @param ast Source file AST\r\n   * @returns Array of variable declaration nodes\r\n   */\r\n  protected getVariableDeclarations(ast: SourceFile): Node[] {\r\n    return this.findNodesByKind(ast, SyntaxKind.VariableDeclaration);\r\n  }\r\n\r\n  /**\r\n   * Get all if statements in the AST\r\n   * @param ast Source file AST\r\n   * @returns Array of if statement nodes\r\n   */\r\n  protected getIfStatements(ast: SourceFile): Node[] {\r\n    return this.findNodesByKind(ast, SyntaxKind.IfStatement);\r\n  }\r\n\r\n  /**\r\n   * Get all call expressions in the AST\r\n   * @param ast Source file AST\r\n   * @returns Array of call expression nodes\r\n   */\r\n  protected getCallExpressions(ast: SourceFile): Node[] {\r\n    return this.findNodesByKind(ast, SyntaxKind.CallExpression);\r\n  }\r\n\r\n  // ============================================================================\r\n  // Code Analysis Utilities\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Calculate the nesting depth of a node\r\n   * @param node AST node\r\n   * @returns Nesting depth (0 for top-level)\r\n   */\r\n  protected getNestingDepth(node: Node): number {\r\n    let depth = 0;\r\n    let current = node.getParent();\r\n\r\n    while (current) {\r\n      const kind = current.getKind();\r\n      // Count blocks that increase nesting\r\n      if (\r\n        kind === SyntaxKind.IfStatement ||\r\n        kind === SyntaxKind.ForStatement ||\r\n        kind === SyntaxKind.WhileStatement ||\r\n        kind === SyntaxKind.DoStatement ||\r\n        kind === SyntaxKind.SwitchStatement ||\r\n        kind === SyntaxKind.CaseClause ||\r\n        kind === SyntaxKind.TryStatement ||\r\n        kind === SyntaxKind.CatchClause\r\n      ) {\r\n        depth++;\r\n      }\r\n      current = current.getParent();\r\n    }\r\n\r\n    return depth;\r\n  }\r\n\r\n  /**\r\n   * Check if a node contains a specific text pattern\r\n   * @param node AST node\r\n   * @param pattern Regular expression pattern\r\n   * @returns True if pattern is found\r\n   */\r\n  protected containsPattern(node: Node, pattern: RegExp): boolean {\r\n    return pattern.test(node.getText());\r\n  }\r\n\r\n  /**\r\n   * Get the name of a named node (function, class, variable, etc.)\r\n   * @param node AST node\r\n   * @returns Name of the node or undefined\r\n   */\r\n  protected getNodeName(node: Node): string | undefined {\r\n    // Try to get name from various node types\r\n    const nodeWithName = node as any;\r\n    \r\n    if (nodeWithName.getName && typeof nodeWithName.getName === 'function') {\r\n      return nodeWithName.getName();\r\n    }\r\n    \r\n    if (nodeWithName.name) {\r\n      return typeof nodeWithName.name === 'string' \r\n        ? nodeWithName.name \r\n        : nodeWithName.name.getText?.();\r\n    }\r\n    \r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Check if a node is exported\r\n   * @param node AST node\r\n   * @returns True if the node is exported\r\n   */\r\n  protected isExported(node: Node): boolean {\r\n    const nodeWithModifiers = node as any;\r\n    \r\n    // First check the node itself\r\n    if (nodeWithModifiers.getModifiers) {\r\n      const modifiers = nodeWithModifiers.getModifiers();\r\n      if (modifiers.some((mod: any) => mod.getKind() === SyntaxKind.ExportKeyword)) {\r\n        return true;\r\n      }\r\n    }\r\n    \r\n    // For variable declarations, check the parent VariableStatement\r\n    if (Node.isVariableDeclaration(node)) {\r\n      const parent = node.getParent(); // VariableDeclarationList\r\n      const grandParent = parent?.getParent(); // VariableStatement\r\n      if (grandParent && (grandParent as any).getModifiers) {\r\n        const modifiers = (grandParent as any).getModifiers();\r\n        return modifiers.some((mod: any) => mod.getKind() === SyntaxKind.ExportKeyword);\r\n      }\r\n    }\r\n    \r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Get all comments associated with a node\r\n   * @param node AST node\r\n   * @returns Array of comment texts\r\n   */\r\n  protected getComments(node: Node): string[] {\r\n    const comments: string[] = [];\r\n    const sourceFile = node.getSourceFile();\r\n    const fullText = sourceFile.getFullText();\r\n    \r\n    // Get leading comments\r\n    const leadingCommentRanges = node.getLeadingCommentRanges();\r\n    for (const range of leadingCommentRanges) {\r\n      comments.push(fullText.substring(range.getPos(), range.getEnd()));\r\n    }\r\n    \r\n    // Get trailing comments\r\n    const trailingCommentRanges = node.getTrailingCommentRanges();\r\n    for (const range of trailingCommentRanges) {\r\n      comments.push(fullText.substring(range.getPos(), range.getEnd()));\r\n    }\r\n    \r\n    return comments;\r\n  }\r\n\r\n  /**\r\n   * Count the number of child nodes\r\n   * @param node AST node\r\n   * @returns Number of direct children\r\n   */\r\n  protected getChildCount(node: Node): number {\r\n    return node.getChildCount();\r\n  }\r\n\r\n  /**\r\n   * Get the text length of a node\r\n   * @param node AST node\r\n   * @returns Length in characters\r\n   */\r\n  protected getTextLength(node: Node): number {\r\n    return node.getText().length;\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\Development\\aluminify\\codebase-cleanup\\src\\analyzers\\service-pattern-analyzer.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":385,"column":65,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":385,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13740,13743],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13740,13743],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Service Pattern Analyzer\r\n * \r\n * Analyzes service layer architecture in the codebase to identify\r\n * inconsistencies, circular dependencies, and unnecessary complexity.\r\n * \r\n * Detects:\r\n * - All service modules in the codebase\r\n * - Service dependencies and import relationships\r\n * - Circular dependencies between services\r\n * - Inconsistent service initialization patterns\r\n * - Unnecessary service abstraction layers\r\n */\r\n\r\nimport { SourceFile, Node, SyntaxKind } from 'ts-morph';\r\nimport { BasePatternAnalyzer } from './pattern-analyzer.js';\r\nimport type { FileInfo, Issue, FileCategory } from '../types.js';\r\n\r\n/**\r\n * Pattern for tracking service modules\r\n */\r\ninterface ServiceModule {\r\n  name: string;\r\n  path: string;\r\n  imports: string[];\r\n  exports: string[];\r\n  node: Node;\r\n}\r\n\r\n/**\r\n * Pattern for tracking service dependencies\r\n */\r\ninterface ServiceDependency {\r\n  from: string;\r\n  to: string;\r\n  importNode: Node;\r\n}\r\n\r\n/**\r\n * Analyzer for service layer patterns\r\n */\r\nexport class ServicePatternAnalyzer extends BasePatternAnalyzer {\r\n  readonly name = 'ServicePatternAnalyzer';\r\n\r\n  // Track all discovered services across files\r\n  private services: Map<string, ServiceModule> = new Map();\r\n  private dependencies: ServiceDependency[] = [];\r\n\r\n  /**\r\n   * Get supported file types for this analyzer\r\n   */\r\n  getSupportedFileTypes(): FileCategory[] {\r\n    return ['service'];\r\n  }\r\n\r\n  /**\r\n   * Analyze a file for service-related issues\r\n   */\r\n  async analyze(file: FileInfo, ast: SourceFile): Promise<Issue[]> {\r\n    const issues: Issue[] = [];\r\n\r\n    // Task 10.1: Discover service modules and analyze dependencies\r\n    issues.push(...this.discoverServiceModule(file, ast));\r\n    issues.push(...this.analyzeServiceDependencies(file, ast));\r\n    issues.push(...this.analyzeServiceImports(file, ast));\r\n\r\n    // Task 10.2: Detect circular dependencies\r\n    // Note: This should be called after all services have been discovered\r\n    // Typically called once after analyzing all files\r\n    issues.push(...this.detectCircularDependencies(file));\r\n\r\n    return issues;\r\n  }\r\n\r\n  // ============================================================================\r\n  // Task 10.1: Service Discovery and Analysis\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Discover and catalog service modules\r\n   * Validates Requirements: 5.1\r\n   */\r\n  private discoverServiceModule(file: FileInfo, ast: SourceFile): Issue[] {\r\n    const issues: Issue[] = [];\r\n\r\n    // Extract service name from file path\r\n    const serviceName = this.extractServiceName(file.relativePath);\r\n    \r\n    if (!serviceName) {\r\n      return issues;\r\n    }\r\n\r\n    // Get all imports from this service\r\n    const imports = this.getImportDeclarations(ast);\r\n    const importedServices: string[] = [];\r\n\r\n    for (const importDecl of imports) {\r\n      // Cast to ImportDeclaration to access getModuleSpecifierValue\r\n      if (!Node.isImportDeclaration(importDecl)) continue;\r\n      const moduleSpecifier = importDecl.getModuleSpecifierValue();\r\n      \r\n      // Check if this import is from another service\r\n      if (this.isServiceImport(moduleSpecifier)) {\r\n        const importedServiceName = this.extractServiceNameFromImport(moduleSpecifier);\r\n        if (importedServiceName) {\r\n          importedServices.push(importedServiceName);\r\n          \r\n          // Track dependency\r\n          this.dependencies.push({\r\n            from: serviceName,\r\n            to: importedServiceName,\r\n            importNode: importDecl,\r\n          });\r\n        }\r\n      }\r\n    }\r\n\r\n    // Get all exports from this service\r\n    const exports = this.getExportDeclarations(ast);\r\n    const exportedNames: string[] = [];\r\n\r\n    // Get named exports\r\n    for (const exportDecl of exports) {\r\n      // Cast to ExportDeclaration to access getNamedExports\r\n      if (!Node.isExportDeclaration(exportDecl)) continue;\r\n      const namedExports = exportDecl.getNamedExports();\r\n      for (const namedExport of namedExports) {\r\n        exportedNames.push(namedExport.getName());\r\n      }\r\n    }\r\n\r\n    // Get exported functions, classes, and variables\r\n    const functions = ast.getFunctions();\r\n    const classes = this.getClassDeclarations(ast);\r\n    const variables = this.getVariableDeclarations(ast);\r\n\r\n    for (const func of functions) {\r\n      if (this.isExported(func)) {\r\n        const funcName = this.getNodeName(func);\r\n        if (funcName) {\r\n          exportedNames.push(funcName);\r\n        }\r\n      }\r\n    }\r\n\r\n    for (const cls of classes) {\r\n      if (this.isExported(cls)) {\r\n        const className = this.getNodeName(cls);\r\n        if (className) {\r\n          exportedNames.push(className);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Store service information\r\n    const serviceModule: ServiceModule = {\r\n      name: serviceName,\r\n      path: file.relativePath,\r\n      imports: importedServices,\r\n      exports: exportedNames,\r\n      node: ast,\r\n    };\r\n\r\n    this.services.set(serviceName, serviceModule);\r\n\r\n    // Check if service has no exports (might be incomplete or unused)\r\n    if (exportedNames.length === 0) {\r\n      issues.push(\r\n        this.createIssue({\r\n          type: 'architectural',\r\n          severity: 'medium',\r\n          category: 'services',\r\n          file: file.relativePath,\r\n          node: ast,\r\n          description: `Service module '${serviceName}' has no exports. This might indicate an incomplete implementation or an unused service file.`,\r\n          recommendation: 'Either add exports to make this service usable, or remove the file if it\\'s no longer needed. Services should export functions, classes, or objects that provide specific functionality.',\r\n          estimatedEffort: 'small',\r\n          tags: ['service', 'architecture', 'unused-code'],\r\n        })\r\n      );\r\n    }\r\n\r\n    return issues;\r\n  }\r\n\r\n  /**\r\n   * Analyze service dependencies for patterns and issues\r\n   * Validates Requirements: 5.1\r\n   */\r\n  private analyzeServiceDependencies(file: FileInfo, ast: SourceFile): Issue[] {\r\n    const issues: Issue[] = [];\r\n\r\n    const serviceName = this.extractServiceName(file.relativePath);\r\n    if (!serviceName) {\r\n      return issues;\r\n    }\r\n\r\n    // Get dependencies for this service\r\n    const serviceDeps = this.dependencies.filter(dep => dep.from === serviceName);\r\n\r\n    // Check for excessive dependencies (might indicate poor separation of concerns)\r\n    if (serviceDeps.length > 5) {\r\n      issues.push(\r\n        this.createIssue({\r\n          type: 'architectural',\r\n          severity: 'medium',\r\n          category: 'services',\r\n          file: file.relativePath,\r\n          node: ast,\r\n          description: `Service '${serviceName}' depends on ${serviceDeps.length} other services. This high number of dependencies suggests the service might have unclear responsibilities or be doing too much.`,\r\n          recommendation: 'Consider breaking this service into smaller, more focused services with clearer responsibilities. Each service should have a single, well-defined purpose. Review the dependencies to see if some functionality could be consolidated or if the service is mixing concerns.',\r\n          estimatedEffort: 'large',\r\n          tags: ['service', 'architecture', 'separation-of-concerns'],\r\n        })\r\n      );\r\n    }\r\n\r\n    // Check for duplicate imports (same service imported multiple times)\r\n    const importCounts = new Map<string, number>();\r\n    for (const dep of serviceDeps) {\r\n      importCounts.set(dep.to, (importCounts.get(dep.to) || 0) + 1);\r\n    }\r\n\r\n    for (const [importedService, count] of importCounts.entries()) {\r\n      if (count > 1) {\r\n        issues.push(\r\n          this.createIssue({\r\n            type: 'inconsistent-pattern',\r\n            severity: 'low',\r\n            category: 'services',\r\n            file: file.relativePath,\r\n            node: ast,\r\n            description: `Service '${importedService}' is imported ${count} times in this file. This might indicate duplicate import statements or inconsistent import patterns.`,\r\n            recommendation: 'Consolidate imports from the same service into a single import statement. This improves code readability and reduces redundancy.',\r\n            estimatedEffort: 'trivial',\r\n            tags: ['service', 'imports', 'code-quality'],\r\n          })\r\n        );\r\n      }\r\n    }\r\n\r\n    return issues;\r\n  }\r\n\r\n  /**\r\n   * Analyze service import patterns and relationships\r\n   * Validates Requirements: 5.1\r\n   */\r\n  private analyzeServiceImports(file: FileInfo, ast: SourceFile): Issue[] {\r\n    const issues: Issue[] = [];\r\n\r\n    const imports = this.getImportDeclarations(ast);\r\n    \r\n    // Track import patterns\r\n    const importPatterns = {\r\n      defaultImports: 0,\r\n      namedImports: 0,\r\n      namespaceImports: 0,\r\n      sideEffectImports: 0,\r\n    };\r\n\r\n    for (const importDecl of imports) {\r\n      // Cast to ImportDeclaration to access import methods\r\n      if (!Node.isImportDeclaration(importDecl)) continue;\r\n      const moduleSpecifier = importDecl.getModuleSpecifierValue();\r\n      \r\n      // Only analyze service imports\r\n      if (!this.isServiceImport(moduleSpecifier)) {\r\n        continue;\r\n      }\r\n\r\n      // Check import type\r\n      const defaultImport = importDecl.getDefaultImport();\r\n      const namedImports = importDecl.getNamedImports();\r\n      const namespaceImport = importDecl.getNamespaceImport();\r\n\r\n      if (defaultImport) {\r\n        importPatterns.defaultImports++;\r\n      }\r\n      \r\n      if (namedImports.length > 0) {\r\n        importPatterns.namedImports++;\r\n      }\r\n      \r\n      if (namespaceImport) {\r\n        importPatterns.namespaceImports++;\r\n      }\r\n      \r\n      if (!defaultImport && namedImports.length === 0 && !namespaceImport) {\r\n        importPatterns.sideEffectImports++;\r\n      }\r\n\r\n      // Check for relative imports that go up multiple levels\r\n      if (moduleSpecifier.startsWith('../')) {\r\n        const levels = (moduleSpecifier.match(/\\.\\.\\//g) || []).length;\r\n        \r\n        if (levels > 2) {\r\n          issues.push(\r\n            this.createIssue({\r\n              type: 'inconsistent-pattern',\r\n              severity: 'low',\r\n              category: 'services',\r\n              file: file.relativePath,\r\n              node: importDecl,\r\n              description: `Import uses ${levels} levels of relative path traversal (${moduleSpecifier}). This makes the code harder to refactor and understand.`,\r\n              recommendation: 'Consider using absolute imports or path aliases (e.g., @/services/...) instead of deep relative imports. This makes imports more maintainable and less fragile during refactoring.',\r\n              estimatedEffort: 'trivial',\r\n              tags: ['service', 'imports', 'maintainability'],\r\n            })\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    // Check for inconsistent import patterns\r\n    const totalServiceImports = importPatterns.defaultImports + \r\n                                importPatterns.namedImports + \r\n                                importPatterns.namespaceImports;\r\n\r\n    if (totalServiceImports > 2) {\r\n      // If we have a mix of default and named imports, flag it\r\n      if (importPatterns.defaultImports > 0 && importPatterns.namedImports > 0) {\r\n        issues.push(\r\n          this.createIssue({\r\n            type: 'inconsistent-pattern',\r\n            severity: 'low',\r\n            category: 'services',\r\n            file: file.relativePath,\r\n            node: ast,\r\n            description: `Inconsistent import patterns detected: ${importPatterns.defaultImports} default imports and ${importPatterns.namedImports} named imports from services. This inconsistency can make the codebase harder to understand.`,\r\n            recommendation: 'Standardize on either default exports or named exports for services. Named exports are generally preferred as they provide better IDE support and make refactoring easier.',\r\n            estimatedEffort: 'small',\r\n            tags: ['service', 'imports', 'consistency'],\r\n          })\r\n        );\r\n      }\r\n    }\r\n\r\n    return issues;\r\n  }\r\n\r\n  // ============================================================================\r\n  // Task 10.2: Circular Dependency Detection\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Detect circular dependencies between services\r\n   * Validates Requirements: 5.3\r\n   * \r\n   * Uses depth-first search to detect cycles in the dependency graph.\r\n   * A circular dependency exists when service A depends on service B,\r\n   * and service B (directly or indirectly) depends on service A.\r\n   */\r\n  private detectCircularDependencies(file: FileInfo): Issue[] {\r\n    const issues: Issue[] = [];\r\n\r\n    const serviceName = this.extractServiceName(file.relativePath);\r\n    if (!serviceName) {\r\n      return issues;\r\n    }\r\n\r\n    // Build dependency graph\r\n    const graph = this.buildDependencyGraph();\r\n\r\n    // Find all cycles that include this service\r\n    const cycles = this.findCyclesInGraph(graph, serviceName);\r\n\r\n    // Create issues for each unique cycle\r\n    for (const cycle of cycles) {\r\n      // Only report the cycle once (from the first service in the cycle alphabetically)\r\n      // This prevents duplicate reports for the same cycle\r\n      const sortedCycle = [...cycle].sort();\r\n      if (sortedCycle[0] !== serviceName) {\r\n        continue;\r\n      }\r\n\r\n      const cycleDescription = cycle.join(' â†’ ') + ' â†’ ' + cycle[0];\r\n      \r\n      issues.push(\r\n        this.createIssue({\r\n          type: 'architectural',\r\n          severity: 'high',\r\n          category: 'services',\r\n          file: file.relativePath,\r\n          node: this.services.get(serviceName)?.node || file as any,\r\n          description: `Circular dependency detected: ${cycleDescription}. This creates tight coupling between services and can lead to initialization problems, testing difficulties, and maintenance issues.`,\r\n          recommendation: `Break the circular dependency by:\r\n1. Extracting shared functionality into a separate service that both services can depend on\r\n2. Using dependency injection to invert the dependency\r\n3. Refactoring to remove the need for one of the dependencies\r\n4. Using events or a message bus to decouple the services\r\n\r\nCircular dependencies are a serious architectural issue that should be resolved to improve code maintainability and testability.`,\r\n          estimatedEffort: 'large',\r\n          tags: ['service', 'architecture', 'circular-dependency', 'coupling'],\r\n        })\r\n      );\r\n    }\r\n\r\n    return issues;\r\n  }\r\n\r\n  /**\r\n   * Build a dependency graph from discovered services\r\n   * Returns a Map where keys are service names and values are arrays of dependent service names\r\n   */\r\n  private buildDependencyGraph(): Map<string, string[]> {\r\n    const graph = new Map<string, string[]>();\r\n\r\n    // Initialize graph with all services\r\n    for (const serviceName of this.services.keys()) {\r\n      graph.set(serviceName, []);\r\n    }\r\n\r\n    // Add dependencies\r\n    for (const dep of this.dependencies) {\r\n      const deps = graph.get(dep.from) || [];\r\n      // Only add if the target service exists in our discovered services\r\n      if (this.services.has(dep.to)) {\r\n        deps.push(dep.to);\r\n        graph.set(dep.from, deps);\r\n      }\r\n    }\r\n\r\n    return graph;\r\n  }\r\n\r\n  /**\r\n   * Find all cycles in the dependency graph that include the given service\r\n   * Uses depth-first search with cycle detection\r\n   */\r\n  private findCyclesInGraph(graph: Map<string, string[]>, startService: string): string[][] {\r\n    const cycles: string[][] = [];\r\n    const visited = new Set<string>();\r\n    const recursionStack = new Set<string>();\r\n    const path: string[] = [];\r\n\r\n    /**\r\n     * Depth-first search to detect cycles\r\n     */\r\n    const dfs = (service: string): void => {\r\n      visited.add(service);\r\n      recursionStack.add(service);\r\n      path.push(service);\r\n\r\n      const dependencies = graph.get(service) || [];\r\n\r\n      for (const dep of dependencies) {\r\n        if (!visited.has(dep)) {\r\n          // Continue DFS\r\n          dfs(dep);\r\n        } else if (recursionStack.has(dep)) {\r\n          // Found a cycle!\r\n          // Extract the cycle from the path\r\n          const cycleStartIndex = path.indexOf(dep);\r\n          if (cycleStartIndex !== -1) {\r\n            const cycle = path.slice(cycleStartIndex);\r\n            \r\n            // Only include cycles that contain the start service\r\n            if (cycle.includes(startService)) {\r\n              // Normalize the cycle to start with the lexicographically smallest service\r\n              // This helps with deduplication\r\n              const minIndex = cycle.indexOf(\r\n                cycle.reduce((min, curr) => (curr < min ? curr : min))\r\n              );\r\n              const normalizedCycle = [\r\n                ...cycle.slice(minIndex),\r\n                ...cycle.slice(0, minIndex),\r\n              ];\r\n              \r\n              // Check if we've already found this cycle\r\n              const cycleKey = normalizedCycle.join('â†’');\r\n              const isDuplicate = cycles.some(\r\n                existingCycle => existingCycle.join('â†’') === cycleKey\r\n              );\r\n              \r\n              if (!isDuplicate) {\r\n                cycles.push(normalizedCycle);\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      path.pop();\r\n      recursionStack.delete(service);\r\n    };\r\n\r\n    // Start DFS from the given service\r\n    dfs(startService);\r\n\r\n    return cycles;\r\n  }\r\n\r\n  // ============================================================================\r\n  // Task 10.3: Service Pattern Inconsistency Detection\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Detect inconsistent service initialization and configuration patterns\r\n   * Validates Requirements: 5.4\r\n   */\r\n  private detectInconsistentInitialization(file: FileInfo, ast: SourceFile): Issue[] {\r\n    const issues: Issue[] = [];\r\n\r\n    const serviceName = this.extractServiceName(file.relativePath);\r\n    if (!serviceName) {\r\n      return issues;\r\n    }\r\n\r\n    // Track initialization patterns found in this service\r\n    const initPatterns = {\r\n      hasConstructor: false,\r\n      hasInitFunction: false,\r\n      hasConfigObject: false,\r\n      hasFactoryFunction: false,\r\n      hasSingletonPattern: false,\r\n      hasDirectExports: false,\r\n    };\r\n\r\n    // Check for class-based services with constructors\r\n    const classes = this.getClassDeclarations(ast);\r\n    for (const cls of classes) {\r\n      if (this.isExported(cls)) {\r\n        // Cast to ClassDeclaration to access getConstructors\r\n        if (!Node.isClassDeclaration(cls)) continue;\r\n        const constructors = cls.getConstructors();\r\n        if (constructors.length > 0) {\r\n          initPatterns.hasConstructor = true;\r\n          \r\n          // Check if constructor has parameters (dependency injection)\r\n          const constructor = constructors[0];\r\n          const params = constructor.getParameters();\r\n          \r\n          // Flag constructors with too many parameters (poor design)\r\n          if (params.length > 5) {\r\n            issues.push(\r\n              this.createIssue({\r\n                type: 'inconsistent-pattern',\r\n                severity: 'medium',\r\n                category: 'services',\r\n                file: file.relativePath,\r\n                node: constructor,\r\n                description: `Service class constructor has ${params.length} parameters. This high number of dependencies suggests the service might be doing too much or have unclear responsibilities.`,\r\n                recommendation: 'Consider breaking this service into smaller, more focused services. Use the Single Responsibility Principle: each service should have one clear purpose. If many dependencies are needed, consider using a configuration object or builder pattern instead of individual parameters.',\r\n                estimatedEffort: 'medium',\r\n                tags: ['service', 'initialization', 'constructor', 'dependencies'],\r\n              })\r\n            );\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // Check for init/initialize/setup functions\r\n    const functions = ast.getFunctions();\r\n    for (const func of functions) {\r\n      const funcName = this.getNodeName(func);\r\n      if (funcName && /^(init|initialize|setup|configure|config)/i.test(funcName)) {\r\n        if (this.isExported(func)) {\r\n          initPatterns.hasInitFunction = true;\r\n        }\r\n      }\r\n      \r\n      // Check for factory functions (create*, make*, build*)\r\n      if (funcName && /^(create|make|build|get)/i.test(funcName)) {\r\n        if (this.isExported(func)) {\r\n          initPatterns.hasFactoryFunction = true;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Check for configuration objects\r\n    const variables = this.getVariableDeclarations(ast);\r\n    for (const varDecl of variables) {\r\n      const varName = this.getNodeName(varDecl);\r\n      if (varName && /config|options|settings/i.test(varName)) {\r\n        if (this.isExported(varDecl)) {\r\n          initPatterns.hasConfigObject = true;\r\n        }\r\n      }\r\n      \r\n      // Check for singleton pattern (instance variable)\r\n      if (varName && /instance|singleton/i.test(varName)) {\r\n        initPatterns.hasSingletonPattern = true;\r\n      }\r\n    }\r\n\r\n    // Check for direct function exports (functional style)\r\n    const exportedFunctions = functions.filter(f => this.isExported(f));\r\n    if (exportedFunctions.length > 0 && !initPatterns.hasConstructor) {\r\n      initPatterns.hasDirectExports = true;\r\n    }\r\n\r\n    // Detect mixed initialization patterns (inconsistency)\r\n    const patternCount = [\r\n      initPatterns.hasConstructor,\r\n      initPatterns.hasInitFunction,\r\n      initPatterns.hasFactoryFunction,\r\n      initPatterns.hasSingletonPattern,\r\n    ].filter(Boolean).length;\r\n\r\n    if (patternCount > 1) {\r\n      const patterns: string[] = [];\r\n      if (initPatterns.hasConstructor) patterns.push('class constructor');\r\n      if (initPatterns.hasInitFunction) patterns.push('init/setup function');\r\n      if (initPatterns.hasFactoryFunction) patterns.push('factory function');\r\n      if (initPatterns.hasSingletonPattern) patterns.push('singleton pattern');\r\n\r\n      issues.push(\r\n        this.createIssue({\r\n          type: 'inconsistent-pattern',\r\n          severity: 'medium',\r\n          category: 'services',\r\n          file: file.relativePath,\r\n          node: ast,\r\n          description: `Service '${serviceName}' uses multiple initialization patterns: ${patterns.join(', ')}. This inconsistency makes the service harder to understand and use correctly.`,\r\n          recommendation: 'Standardize on a single initialization pattern for this service. Choose one approach:\\n1. Class-based with constructor injection (good for stateful services)\\n2. Factory functions (good for creating instances)\\n3. Direct function exports (good for stateless utilities)\\n4. Singleton pattern (use sparingly, only when truly needed)\\n\\nConsistency in initialization patterns makes the codebase more predictable and easier to maintain.',\r\n          estimatedEffort: 'medium',\r\n          tags: ['service', 'initialization', 'consistency', 'pattern'],\r\n        })\r\n      );\r\n    }\r\n\r\n    // Check for services with no clear initialization pattern\r\n    if (patternCount === 0 && !initPatterns.hasDirectExports) {\r\n      issues.push(\r\n        this.createIssue({\r\n          type: 'inconsistent-pattern',\r\n          severity: 'low',\r\n          category: 'services',\r\n          file: file.relativePath,\r\n          node: ast,\r\n          description: `Service '${serviceName}' has no clear initialization pattern. It's unclear how this service should be instantiated or configured.`,\r\n          recommendation: 'Add a clear initialization pattern to this service. Consider:\\n1. Exporting a class with a constructor\\n2. Exporting a factory function (e.g., createService())\\n3. Exporting direct functions if this is a stateless utility\\n\\nClear initialization patterns make services easier to use and test.',\r\n          estimatedEffort: 'small',\r\n          tags: ['service', 'initialization', 'clarity'],\r\n        })\r\n      );\r\n    }\r\n\r\n    return issues;\r\n  }\r\n\r\n  /**\r\n   * Detect unnecessary service abstraction layers\r\n   * Validates Requirements: 5.5\r\n   */\r\n  private detectUnnecessaryAbstractions(file: FileInfo, ast: SourceFile): Issue[] {\r\n    const issues: Issue[] = [];\r\n\r\n    const serviceName = this.extractServiceName(file.relativePath);\r\n    if (!serviceName) {\r\n      return issues;\r\n    }\r\n\r\n    // Check all exported functions for pass-through behavior\r\n    const functions = ast.getFunctions();\r\n    \r\n    for (const func of functions) {\r\n      if (!this.isExported(func)) {\r\n        continue;\r\n      }\r\n\r\n      const funcName = this.getNodeName(func);\r\n      if (!funcName) {\r\n        continue;\r\n      }\r\n\r\n      // Get function body\r\n      const body = func.getBody();\r\n      if (!body || !Node.isBlock(body)) {\r\n        continue;\r\n      }\r\n\r\n      const statements = body.getStatements();\r\n      \r\n      // Check for single-statement functions (potential pass-through)\r\n      if (statements.length === 1) {\r\n        const statement = statements[0];\r\n        \r\n        // Check if it's a return statement\r\n        if (Node.isReturnStatement(statement)) {\r\n          const returnExpr = statement.getExpression();\r\n          \r\n          if (returnExpr) {\r\n            // Check if it's a simple call expression (pass-through)\r\n            if (Node.isCallExpression(returnExpr)) {\r\n              const callExpr = returnExpr;\r\n              const calledExpr = callExpr.getExpression();\r\n              \r\n              // Check if parameters are just passed through\r\n              const funcParams = func.getParameters();\r\n              const callArgs = callExpr.getArguments();\r\n              \r\n              // Simple heuristic: if parameter count matches and function just calls another function\r\n              if (funcParams.length === callArgs.length) {\r\n                // Check if all arguments are simple identifiers matching parameters\r\n                let isSimplePassThrough = true;\r\n                const paramNames = funcParams.map(p => p.getName());\r\n                \r\n                for (let i = 0; i < callArgs.length; i++) {\r\n                  const arg = callArgs[i];\r\n                  if (Node.isIdentifier(arg)) {\r\n                    if (arg.getText() !== paramNames[i]) {\r\n                      isSimplePassThrough = false;\r\n                      break;\r\n                    }\r\n                  } else {\r\n                    // Argument is not a simple identifier\r\n                    isSimplePassThrough = false;\r\n                    break;\r\n                  }\r\n                }\r\n                \r\n                if (isSimplePassThrough) {\r\n                  const calledFunctionName = calledExpr.getText();\r\n                  \r\n                  issues.push(\r\n                    this.createIssue({\r\n                      type: 'unnecessary-adapter',\r\n                      severity: 'low',\r\n                      category: 'services',\r\n                      file: file.relativePath,\r\n                      node: func,\r\n                      description: `Function '${funcName}' is a simple pass-through wrapper that just calls '${calledFunctionName}' with the same parameters. This abstraction layer adds no value and increases code complexity.`,\r\n                      recommendation: `Consider removing this wrapper function and using '${calledFunctionName}' directly. If this wrapper exists for a specific reason (e.g., to provide a stable API while the implementation changes), document that reason clearly. Otherwise, unnecessary abstraction layers make code harder to navigate and maintain.`,\r\n                      estimatedEffort: 'trivial',\r\n                      tags: ['service', 'abstraction', 'wrapper', 'pass-through'],\r\n                    })\r\n                  );\r\n                }\r\n              }\r\n            }\r\n            \r\n            // Check for simple property access pass-through\r\n            if (Node.isPropertyAccessExpression(returnExpr)) {\r\n              issues.push(\r\n                this.createIssue({\r\n                  type: 'unnecessary-adapter',\r\n                  severity: 'low',\r\n                  category: 'services',\r\n                  file: file.relativePath,\r\n                  node: func,\r\n                  description: `Function '${funcName}' simply returns a property access (${returnExpr.getText()}). This adds an unnecessary abstraction layer.`,\r\n                  recommendation: 'Consider exposing the property directly or removing this wrapper function. Simple property access wrappers add little value and make code harder to follow.',\r\n                  estimatedEffort: 'trivial',\r\n                  tags: ['service', 'abstraction', 'wrapper', 'property-access'],\r\n                })\r\n              );\r\n            }\r\n          }\r\n        }\r\n      }\r\n      \r\n      // Check for functions with only trivial transformations\r\n      if (statements.length === 2) {\r\n        // Pattern: const result = someCall(); return result;\r\n        const firstStmt = statements[0];\r\n        const secondStmt = statements[1];\r\n        \r\n        if (Node.isVariableStatement(firstStmt) && Node.isReturnStatement(secondStmt)) {\r\n          const varDecls = firstStmt.getDeclarations();\r\n          if (varDecls.length === 1) {\r\n            const varDecl = varDecls[0];\r\n            const varName = varDecl.getName();\r\n            const returnExpr = secondStmt.getExpression();\r\n            \r\n            // Check if return statement just returns the variable\r\n            if (returnExpr && Node.isIdentifier(returnExpr) && returnExpr.getText() === varName) {\r\n              const initializer = varDecl.getInitializer();\r\n              \r\n              if (initializer && Node.isCallExpression(initializer)) {\r\n                // This is a pass-through with an intermediate variable\r\n                issues.push(\r\n                  this.createIssue({\r\n                    type: 'unnecessary-adapter',\r\n                    severity: 'low',\r\n                    category: 'services',\r\n                    file: file.relativePath,\r\n                    node: func,\r\n                    description: `Function '${funcName}' is a pass-through wrapper that calls another function and immediately returns the result without any transformation or additional logic.`,\r\n                    recommendation: 'Consider removing this wrapper function unless it serves a specific architectural purpose (e.g., providing a stable API, adding logging, or handling errors). Document the reason if the wrapper is intentional.',\r\n                    estimatedEffort: 'trivial',\r\n                    tags: ['service', 'abstraction', 'wrapper', 'pass-through'],\r\n                  })\r\n                );\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // Check for wrapper classes that just delegate to another class\r\n    const classes = this.getClassDeclarations(ast);\r\n    \r\n    for (const cls of classes) {\r\n      if (!this.isExported(cls)) {\r\n        continue;\r\n      }\r\n\r\n      const className = this.getNodeName(cls);\r\n      if (!className) {\r\n        continue;\r\n      }\r\n\r\n      // Cast to ClassDeclaration to access getMethods\r\n      if (!Node.isClassDeclaration(cls)) continue;\r\n      const methods = cls.getMethods();\r\n      let passThroughMethodCount = 0;\r\n      \r\n      for (const method of methods) {\r\n        const methodBody = method.getBody();\r\n        if (!methodBody || !Node.isBlock(methodBody)) {\r\n          continue;\r\n        }\r\n\r\n        const statements = methodBody.getStatements();\r\n        \r\n        // Check for single-statement methods that just delegate\r\n        if (statements.length === 1) {\r\n          const statement = statements[0];\r\n          \r\n          if (Node.isReturnStatement(statement)) {\r\n            const returnExpr = statement.getExpression();\r\n            \r\n            if (returnExpr && Node.isCallExpression(returnExpr)) {\r\n              const callExpr = returnExpr;\r\n              const calledExpr = callExpr.getExpression();\r\n              \r\n              // Check if it's calling a method on a member variable (delegation)\r\n              if (Node.isPropertyAccessExpression(calledExpr)) {\r\n                passThroughMethodCount++;\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n      \r\n      // If most methods are pass-through, flag the class as unnecessary abstraction\r\n      if (methods.length > 0 && passThroughMethodCount / methods.length > 0.7) {\r\n        issues.push(\r\n          this.createIssue({\r\n            type: 'unnecessary-adapter',\r\n            severity: 'medium',\r\n            category: 'services',\r\n            file: file.relativePath,\r\n            node: cls,\r\n            description: `Class '${className}' appears to be a wrapper class where ${passThroughMethodCount} out of ${methods.length} methods simply delegate to another object. This abstraction layer may be unnecessary.`,\r\n            recommendation: 'Consider whether this wrapper class is needed. If it\\'s just delegating calls without adding value (no error handling, logging, transformation, or business logic), consider using the wrapped class directly. If the wrapper serves a specific purpose (e.g., adapter pattern for third-party libraries, providing a stable API), document that clearly.',\r\n            estimatedEffort: 'medium',\r\n            tags: ['service', 'abstraction', 'wrapper', 'delegation', 'class'],\r\n          })\r\n        );\r\n      }\r\n    }\r\n\r\n    return issues;\r\n  }\r\n\r\n  // ============================================================================\r\n  // Helper Methods\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Extract service name from file path\r\n   * Examples:\r\n   *   backend/services/user/index.ts -> user\r\n   *   backend/services/auth/auth-service.ts -> auth\r\n   *   services/database/db.ts -> database\r\n   */\r\n  private extractServiceName(filePath: string): string | null {\r\n    // Normalize path separators\r\n    const normalizedPath = filePath.replace(/\\\\/g, '/');\r\n    \r\n    // Match patterns like: backend/services/NAME/... or services/NAME/...\r\n    const serviceMatch = normalizedPath.match(/(?:backend\\/)?services\\/([^\\/]+)/);\r\n    \r\n    if (serviceMatch) {\r\n      return serviceMatch[1];\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Check if an import is from a service module\r\n   */\r\n  private isServiceImport(moduleSpecifier: string): boolean {\r\n    // Normalize path separators\r\n    const normalizedPath = moduleSpecifier.replace(/\\\\/g, '/');\r\n    \r\n    // Check for service imports\r\n    return normalizedPath.includes('/services/') || \r\n           normalizedPath.includes('services/') ||\r\n           normalizedPath.startsWith('@/services/') ||\r\n           normalizedPath.startsWith('~/services/');\r\n  }\r\n\r\n  /**\r\n   * Extract service name from import path\r\n   */\r\n  private extractServiceNameFromImport(moduleSpecifier: string): string | null {\r\n    // Normalize path separators\r\n    const normalizedPath = moduleSpecifier.replace(/\\\\/g, '/');\r\n    \r\n    // Match patterns like: ../services/NAME or @/services/NAME\r\n    const serviceMatch = normalizedPath.match(/services\\/([^\\/]+)/);\r\n    \r\n    if (serviceMatch) {\r\n      return serviceMatch[1];\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Get all discovered services\r\n   * This can be used by other analyzers or for reporting\r\n   */\r\n  public getDiscoveredServices(): Map<string, ServiceModule> {\r\n    return this.services;\r\n  }\r\n\r\n  /**\r\n   * Get all service dependencies\r\n   * This can be used for circular dependency detection\r\n   */\r\n  public getServiceDependencies(): ServiceDependency[] {\r\n    return this.dependencies;\r\n  }\r\n\r\n  /**\r\n   * Clear the analyzer state (useful for testing or re-analysis)\r\n   */\r\n  public reset(): void {\r\n    this.services.clear();\r\n    this.dependencies = [];\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\Development\\aluminify\\codebase-cleanup\\src\\analyzers\\type-pattern-analyzer.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":327,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":327,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10170,10173],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10170,10173],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":756,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":756,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[26109,26112],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[26109,26112],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Type Pattern Analyzer\r\n * \r\n * Analyzes TypeScript type definitions and usage patterns in the codebase\r\n * to identify inconsistencies, redundancies, and type safety issues.\r\n * \r\n * Detects:\r\n * - All type definitions (interfaces, types, enums)\r\n * - Type usage across files\r\n * - Duplicate type definitions\r\n * - Inconsistent type definitions for same entities\r\n * - Excessive 'any' type usage\r\n * - Type assertions that could be avoided\r\n * - Mismatches between Supabase generated types and manual types\r\n */\r\n\r\nimport { SourceFile, Node, SyntaxKind } from 'ts-morph';\r\nimport { BasePatternAnalyzer } from './pattern-analyzer.js';\r\nimport type { FileInfo, Issue, FileCategory } from '../types.js';\r\n\r\n/**\r\n * Information about a type definition\r\n */\r\ninterface TypeDefinition {\r\n  name: string;\r\n  kind: 'interface' | 'type' | 'enum';\r\n  node: Node;\r\n  file: string;\r\n  definition: string;\r\n}\r\n\r\n/**\r\n * Information about type usage\r\n */\r\ninterface TypeUsage {\r\n  typeName: string;\r\n  node: Node;\r\n  file: string;\r\n  context: string; // 'variable' | 'parameter' | 'return' | 'property'\r\n}\r\n\r\n/**\r\n * Analyzer for TypeScript type patterns\r\n */\r\nexport class TypePatternAnalyzer extends BasePatternAnalyzer {\r\n  readonly name = 'TypePatternAnalyzer';\r\n\r\n  // Track type definitions across files for cross-file analysis\r\n  private typeDefinitions: TypeDefinition[] = [];\r\n  private typeUsages: TypeUsage[] = [];\r\n\r\n  /**\r\n   * Get supported file types for this analyzer\r\n   */\r\n  getSupportedFileTypes(): FileCategory[] {\r\n    return ['type', 'component', 'api-route', 'service', 'util'];\r\n  }\r\n\r\n  /**\r\n   * Analyze a file for type-related issues\r\n   */\r\n  async analyze(file: FileInfo, ast: SourceFile): Promise<Issue[]> {\r\n    const issues: Issue[] = [];\r\n\r\n    // Task 8.1: Find all type definitions and track type usage\r\n    this.discoverTypeDefinitions(file, ast);\r\n    this.trackTypeUsage(file, ast);\r\n\r\n    // Task 8.2: Detect type inconsistencies\r\n    // Note: This requires cross-file analysis, so we detect issues after all files are analyzed\r\n    // The detectTypeInconsistencies() method should be called after analyzing all files\r\n\r\n    // Task 8.3: Detect type safety issues\r\n    issues.push(...this.detectExcessiveAnyUsage(file, ast));\r\n    issues.push(...this.detectUnnecessaryTypeAssertions(file, ast));\r\n\r\n    return issues;\r\n  }\r\n\r\n  /**\r\n   * Detect type inconsistencies across all analyzed files\r\n   * This method should be called after all files have been analyzed\r\n   * Validates Requirements: 7.2, 7.4, 7.5\r\n   */\r\n  public detectTypeInconsistencies(): Issue[] {\r\n    const issues: Issue[] = [];\r\n\r\n    // Detect duplicate type definitions for the same entities\r\n    issues.push(...this.detectDuplicateTypeDefinitions());\r\n\r\n    // Detect mismatches between Supabase types and manual types\r\n    issues.push(...this.detectSupabaseTypeMismatches());\r\n\r\n    return issues;\r\n  }\r\n\r\n  // ============================================================================\r\n  // Task 8.1: Type Definition Discovery\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Find all type definitions (interfaces, types, enums) in the file\r\n   * Validates Requirements: 7.1\r\n   */\r\n  private discoverTypeDefinitions(file: FileInfo, ast: SourceFile): void {\r\n    // Find all interface declarations\r\n    const interfaces = ast.getInterfaces();\r\n    for (const interfaceDecl of interfaces) {\r\n      const name = interfaceDecl.getName();\r\n      \r\n      this.typeDefinitions.push({\r\n        name,\r\n        kind: 'interface',\r\n        node: interfaceDecl,\r\n        file: file.relativePath,\r\n        definition: interfaceDecl.getText(),\r\n      });\r\n    }\r\n\r\n    // Find all type alias declarations\r\n    const typeAliases = ast.getTypeAliases();\r\n    for (const typeAlias of typeAliases) {\r\n      const name = typeAlias.getName();\r\n      \r\n      this.typeDefinitions.push({\r\n        name,\r\n        kind: 'type',\r\n        node: typeAlias,\r\n        file: file.relativePath,\r\n        definition: typeAlias.getText(),\r\n      });\r\n    }\r\n\r\n    // Find all enum declarations\r\n    const enums = ast.getEnums();\r\n    for (const enumDecl of enums) {\r\n      const name = enumDecl.getName();\r\n      \r\n      this.typeDefinitions.push({\r\n        name,\r\n        kind: 'enum',\r\n        node: enumDecl,\r\n        file: file.relativePath,\r\n        definition: enumDecl.getText(),\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Track type usage across the file\r\n   * Validates Requirements: 7.1\r\n   */\r\n  private trackTypeUsage(file: FileInfo, ast: SourceFile): void {\r\n    // Track type usage in variable declarations\r\n    const variableDeclarations = this.getVariableDeclarations(ast);\r\n    for (const varDecl of variableDeclarations) {\r\n      // Cast to VariableDeclaration to access getTypeNode\r\n      if (!Node.isVariableDeclaration(varDecl)) continue;\r\n      const typeNode = varDecl.getTypeNode();\r\n      if (typeNode) {\r\n        const typeName = this.extractTypeName(typeNode);\r\n        if (typeName) {\r\n          this.typeUsages.push({\r\n            typeName,\r\n            node: varDecl,\r\n            file: file.relativePath,\r\n            context: 'variable',\r\n          });\r\n        }\r\n      }\r\n    }\r\n\r\n    // Track type usage in function parameters\r\n    const functions = [\r\n      ...ast.getFunctions(),\r\n      ...this.findNodesByKind(ast, SyntaxKind.ArrowFunction),\r\n      ...this.findNodesByKind(ast, SyntaxKind.FunctionExpression),\r\n      ...this.findNodesByKind(ast, SyntaxKind.MethodDeclaration),\r\n    ];\r\n\r\n    for (const func of functions) {\r\n      const parameters = this.getFunctionParameters(func);\r\n      for (const param of parameters) {\r\n        // Cast to ParameterDeclaration to access getTypeNode\r\n        if (!Node.isParameterDeclaration(param)) continue;\r\n        const typeNode = param.getTypeNode();\r\n        if (typeNode) {\r\n          const typeName = this.extractTypeName(typeNode);\r\n          if (typeName) {\r\n            this.typeUsages.push({\r\n              typeName,\r\n              node: param,\r\n              file: file.relativePath,\r\n              context: 'parameter',\r\n            });\r\n          }\r\n        }\r\n      }\r\n\r\n      // Track return type usage\r\n      // Check if this is a function-like node with getReturnTypeNode\r\n      let returnTypeNode: Node | undefined;\r\n      if (Node.isFunctionDeclaration(func) || Node.isArrowFunction(func) || \r\n          Node.isFunctionExpression(func) || Node.isMethodDeclaration(func)) {\r\n        returnTypeNode = func.getReturnTypeNode();\r\n      }\r\n      if (returnTypeNode) {\r\n        const typeName = this.extractTypeName(returnTypeNode);\r\n        if (typeName) {\r\n          this.typeUsages.push({\r\n            typeName,\r\n            node: func,\r\n            file: file.relativePath,\r\n            context: 'return',\r\n          });\r\n        }\r\n      }\r\n    }\r\n\r\n    // Track type usage in interface/type properties\r\n    const interfaces = ast.getInterfaces();\r\n    for (const interfaceDecl of interfaces) {\r\n      const properties = interfaceDecl.getProperties();\r\n      for (const prop of properties) {\r\n        const typeNode = prop.getTypeNode();\r\n        if (typeNode) {\r\n          const typeName = this.extractTypeName(typeNode);\r\n          if (typeName) {\r\n            this.typeUsages.push({\r\n              typeName,\r\n              node: prop,\r\n              file: file.relativePath,\r\n              context: 'property',\r\n            });\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    const typeAliases = ast.getTypeAliases();\r\n    for (const typeAlias of typeAliases) {\r\n      const typeNode = typeAlias.getTypeNode();\r\n      if (typeNode) {\r\n        const typeName = this.extractTypeName(typeNode);\r\n        if (typeName) {\r\n          this.typeUsages.push({\r\n            typeName,\r\n            node: typeAlias,\r\n            file: file.relativePath,\r\n            context: 'property',\r\n          });\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Extract the type name from a type node\r\n   * Handles simple types, generic types, and complex type expressions\r\n   */\r\n  private extractTypeName(typeNode: Node): string | null {\r\n    const typeText = typeNode.getText();\r\n\r\n    // Handle simple type references (e.g., \"User\", \"string\", \"number\")\r\n    if (/^[A-Z][a-zA-Z0-9_]*$/.test(typeText)) {\r\n      return typeText;\r\n    }\r\n\r\n    // Handle generic types (e.g., \"Array<User>\", \"Promise<User>\")\r\n    const genericMatch = typeText.match(/^([A-Z][a-zA-Z0-9_]*)<(.+)>$/);\r\n    if (genericMatch) {\r\n      // Return the inner type for tracking\r\n      return this.extractTypeName({ getText: () => genericMatch[2] } as Node);\r\n    }\r\n\r\n    // Handle union types (e.g., \"User | null\")\r\n    if (typeText.includes('|')) {\r\n      const types = typeText.split('|').map(t => t.trim());\r\n      // Return the first non-primitive type\r\n      for (const type of types) {\r\n        if (/^[A-Z][a-zA-Z0-9_]*$/.test(type)) {\r\n          return type;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Handle intersection types (e.g., \"User & Timestamps\")\r\n    if (typeText.includes('&')) {\r\n      const types = typeText.split('&').map(t => t.trim());\r\n      // Return the first type\r\n      for (const type of types) {\r\n        if (/^[A-Z][a-zA-Z0-9_]*$/.test(type)) {\r\n          return type;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Handle array types (e.g., \"User[]\")\r\n    const arrayMatch = typeText.match(/^([A-Z][a-zA-Z0-9_]*)\\[\\]$/);\r\n    if (arrayMatch) {\r\n      return arrayMatch[1];\r\n    }\r\n\r\n    // Handle Supabase Database types (e.g., \"Database['public']['Tables']['users']['Row']\")\r\n    if (typeText.includes('Database[')) {\r\n      const tableMatch = typeText.match(/\\['Tables'\\]\\['([^']+)'\\]/);\r\n      if (tableMatch) {\r\n        // Return a normalized name for the table type\r\n        return `Db${this.capitalize(tableMatch[1])}`;\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Capitalize the first letter of a string\r\n   */\r\n  private capitalize(str: string): string {\r\n    return str.charAt(0).toUpperCase() + str.slice(1);\r\n  }\r\n\r\n  /**\r\n   * Get parameters from a function node\r\n   */\r\n  private getFunctionParameters(func: Node): Node[] {\r\n    const funcWithParams = func as any;\r\n    if (funcWithParams.getParameters && typeof funcWithParams.getParameters === 'function') {\r\n      return funcWithParams.getParameters();\r\n    }\r\n    return [];\r\n  }\r\n\r\n  // ============================================================================\r\n  // Public API for accessing tracked data\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Get all discovered type definitions\r\n   * Useful for cross-file analysis and reporting\r\n   */\r\n  public getTypeDefinitions(): TypeDefinition[] {\r\n    return this.typeDefinitions;\r\n  }\r\n\r\n  /**\r\n   * Get all tracked type usages\r\n   * Useful for cross-file analysis and reporting\r\n   */\r\n  public getTypeUsages(): TypeUsage[] {\r\n    return this.typeUsages;\r\n  }\r\n\r\n  /**\r\n   * Get type definitions by name\r\n   */\r\n  public getTypeDefinitionsByName(name: string): TypeDefinition[] {\r\n    return this.typeDefinitions.filter(def => def.name === name);\r\n  }\r\n\r\n  /**\r\n   * Get type usages by name\r\n   */\r\n  public getTypeUsagesByName(name: string): TypeUsage[] {\r\n    return this.typeUsages.filter(usage => usage.typeName === name);\r\n  }\r\n\r\n  /**\r\n   * Clear tracked data (useful for testing or re-analysis)\r\n   */\r\n  public clearTrackedData(): void {\r\n    this.typeDefinitions = [];\r\n    this.typeUsages = [];\r\n  }\r\n\r\n  // ============================================================================\r\n  // Task 8.2: Type Inconsistency Detection\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Detect duplicate type definitions for the same entities\r\n   * Validates Requirements: 7.2, 7.4\r\n   */\r\n  private detectDuplicateTypeDefinitions(): Issue[] {\r\n    const issues: Issue[] = [];\r\n    const typesByName = new Map<string, TypeDefinition[]>();\r\n\r\n    // Group type definitions by name\r\n    for (const typeDef of this.typeDefinitions) {\r\n      const existing = typesByName.get(typeDef.name) || [];\r\n      existing.push(typeDef);\r\n      typesByName.set(typeDef.name, existing);\r\n    }\r\n\r\n    // Check for duplicates\r\n    for (const [typeName, definitions] of typesByName.entries()) {\r\n      if (definitions.length > 1) {\r\n        // We have duplicate type definitions\r\n        const files = definitions.map(d => d.file).join(', ');\r\n        \r\n        // Check if definitions are identical or different\r\n        const uniqueDefinitions = new Set(definitions.map(d => this.normalizeTypeDefinition(d.definition)));\r\n        \r\n        if (uniqueDefinitions.size === 1) {\r\n          // Identical definitions - code duplication\r\n          for (const def of definitions) {\r\n            issues.push(\r\n              this.createIssue({\r\n                type: 'code-duplication',\r\n                severity: 'medium',\r\n                category: 'types',\r\n                file: def.file,\r\n                node: def.node,\r\n                description: `Duplicate type definition '${typeName}' found in ${definitions.length} files: ${files}`,\r\n                recommendation: `Consolidate the type definition '${typeName}' into a single shared type file and import it where needed. This reduces maintenance burden and ensures consistency.`,\r\n                estimatedEffort: 'small',\r\n                tags: ['duplicate-type', 'type-consolidation', typeName],\r\n              })\r\n            );\r\n          }\r\n        } else {\r\n          // Different definitions - inconsistent types\r\n          for (const def of definitions) {\r\n            issues.push(\r\n              this.createIssue({\r\n                type: 'inconsistent-pattern',\r\n                severity: 'high',\r\n                category: 'types',\r\n                file: def.file,\r\n                node: def.node,\r\n                description: `Inconsistent type definition for '${typeName}' found across ${definitions.length} files: ${files}. The definitions differ in structure or properties.`,\r\n                recommendation: `Review all definitions of '${typeName}' and establish a single canonical definition. Ensure all usages align with the canonical type. Consider if these should be different types with different names.`,\r\n                estimatedEffort: 'medium',\r\n                tags: ['inconsistent-type', 'type-mismatch', typeName],\r\n              })\r\n            );\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return issues;\r\n  }\r\n\r\n  /**\r\n   * Detect mismatches between Supabase generated types and manual type definitions\r\n   * Validates Requirements: 7.5\r\n   */\r\n  private detectSupabaseTypeMismatches(): Issue[] {\r\n    const issues: Issue[] = [];\r\n    \r\n    // Find Supabase database type definitions\r\n    const supabaseTypes = this.typeDefinitions.filter(def => \r\n      def.file.includes('database.types') || \r\n      def.file.includes('supabase') ||\r\n      def.definition.includes(\"Database['public']['Tables']\")\r\n    );\r\n\r\n    // Find manual type definitions that might correspond to database entities\r\n    const manualTypes = this.typeDefinitions.filter(def => \r\n      !def.file.includes('database.types') && \r\n      !def.file.includes('supabase')\r\n    );\r\n\r\n    // Check for potential mismatches\r\n    for (const manualType of manualTypes) {\r\n      // Check if there's a corresponding Supabase type\r\n      const potentialSupabaseType = this.findCorrespondingSupabaseType(manualType, supabaseTypes);\r\n      \r\n      if (potentialSupabaseType) {\r\n        // We found a potential mismatch - manual type exists alongside Supabase type\r\n        issues.push(\r\n          this.createIssue({\r\n            type: 'inconsistent-pattern',\r\n            severity: 'high',\r\n            category: 'types',\r\n            file: manualType.file,\r\n            node: manualType.node,\r\n            description: `Manual type definition '${manualType.name}' may conflict with Supabase generated type. Found potential Supabase type in ${potentialSupabaseType.file}.`,\r\n            recommendation: `Use Supabase generated types instead of manual definitions to ensure type safety with the database schema. Import the type from the generated types file: import type { ${manualType.name} } from '@/types/database.types'`,\r\n            estimatedEffort: 'small',\r\n            tags: ['supabase-type-mismatch', 'database-type', manualType.name],\r\n          })\r\n        );\r\n      }\r\n    }\r\n\r\n    // Check for usage of Database['public']['Tables'] pattern outside of type files\r\n    for (const usage of this.typeUsages) {\r\n      if (usage.typeName.startsWith('Db') && !usage.file.includes('database.types')) {\r\n        // This is likely a Supabase type being used directly\r\n        // Check if there's a manual type that should be used instead\r\n        const manualType = this.typeDefinitions.find(def => \r\n          def.name === usage.typeName && \r\n          !def.file.includes('database.types')\r\n        );\r\n\r\n        if (!manualType) {\r\n          // Using Supabase type directly without a proper type alias\r\n          // This is actually good practice, so we don't flag it as an issue\r\n          continue;\r\n        }\r\n      }\r\n    }\r\n\r\n    return issues;\r\n  }\r\n\r\n  /**\r\n   * Find a corresponding Supabase type for a manual type definition\r\n   */\r\n  private findCorrespondingSupabaseType(\r\n    manualType: TypeDefinition, \r\n    supabaseTypes: TypeDefinition[]\r\n  ): TypeDefinition | null {\r\n    // Look for Supabase types with similar names\r\n    const manualName = manualType.name.toLowerCase();\r\n    \r\n    for (const supabaseType of supabaseTypes) {\r\n      const supabaseName = supabaseType.name.toLowerCase();\r\n      \r\n      // Check for exact match\r\n      if (manualName === supabaseName) {\r\n        return supabaseType;\r\n      }\r\n      \r\n      // Check for common patterns:\r\n      // - User vs users (singular vs plural)\r\n      // - User vs DbUser\r\n      // - UserProfile vs user_profiles\r\n      \r\n      if (\r\n        manualName === supabaseName + 's' ||\r\n        manualName + 's' === supabaseName ||\r\n        manualName === 'db' + supabaseName ||\r\n        'db' + manualName === supabaseName ||\r\n        manualName.replace(/_/g, '') === supabaseName.replace(/_/g, '')\r\n      ) {\r\n        return supabaseType;\r\n      }\r\n      \r\n      // Check if the Supabase type definition references a table with similar name\r\n      if (supabaseType.definition.includes(`['${manualName}']`) ||\r\n          supabaseType.definition.includes(`['${manualName}s']`) ||\r\n          supabaseType.definition.includes(`['${manualName.replace(/([A-Z])/g, '_$1').toLowerCase()}']`)) {\r\n        return supabaseType;\r\n      }\r\n    }\r\n    \r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Normalize a type definition for comparison\r\n   * Removes whitespace and formatting differences\r\n   */\r\n  private normalizeTypeDefinition(definition: string): string {\r\n    return definition\r\n      .replace(/\\s+/g, ' ')  // Normalize whitespace\r\n      .replace(/,\\s*}/g, '}')  // Remove trailing commas\r\n      .replace(/;\\s*}/g, '}')  // Remove trailing semicolons\r\n      .trim();\r\n  }\r\n\r\n  // ============================================================================\r\n  // Task 8.3: Type Safety Issue Detection\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Detect excessive 'any' type usage\r\n   * Validates Requirements: 7.3\r\n   */\r\n  private detectExcessiveAnyUsage(file: FileInfo, ast: SourceFile): Issue[] {\r\n    const issues: Issue[] = [];\r\n\r\n    // Find all occurrences of 'any' type in the file\r\n    const anyTypeNodes = this.findAnyTypeUsage(ast);\r\n\r\n    for (const node of anyTypeNodes) {\r\n      // Determine the context of the 'any' usage\r\n      const context = this.getAnyTypeContext(node);\r\n      \r\n      // Create an issue for each 'any' usage\r\n      issues.push(\r\n        this.createIssue({\r\n          type: 'type-safety',\r\n          severity: 'medium',\r\n          category: 'types',\r\n          file: file.relativePath,\r\n          node: node,\r\n          description: `Excessive use of 'any' type detected in ${context}. This bypasses TypeScript's type checking and reduces type safety.`,\r\n          recommendation: `Replace 'any' with a specific type. Consider using: 1) A proper interface or type definition, 2) Generic types for flexible but type-safe code, 3) 'unknown' if the type is truly unknown (requires type guards), 4) Union types for multiple possible types.`,\r\n          estimatedEffort: 'small',\r\n          tags: ['any-type', 'type-safety', context],\r\n        })\r\n      );\r\n    }\r\n\r\n    return issues;\r\n  }\r\n\r\n  /**\r\n   * Detect unnecessary type assertions\r\n   * Validates Requirements: 7.3\r\n   */\r\n  private detectUnnecessaryTypeAssertions(file: FileInfo, ast: SourceFile): Issue[] {\r\n    const issues: Issue[] = [];\r\n\r\n    // Find all type assertions (as Type and <Type>)\r\n    const typeAssertions = this.findTypeAssertions(ast);\r\n\r\n    for (const assertion of typeAssertions) {\r\n      // Check if the type assertion is unnecessary\r\n      if (this.isTypeAssertionUnnecessary(assertion)) {\r\n        const assertedType = this.getAssertedType(assertion);\r\n        \r\n        issues.push(\r\n          this.createIssue({\r\n            type: 'type-safety',\r\n            severity: 'low',\r\n            category: 'types',\r\n            file: file.relativePath,\r\n            node: assertion,\r\n            description: `Unnecessary type assertion to '${assertedType}' detected. The expression already has the correct type or TypeScript can infer it.`,\r\n            recommendation: `Remove the type assertion and let TypeScript infer the type naturally. If the assertion is needed for a specific reason, add a comment explaining why. Type assertions should only be used when you have more information about the type than TypeScript can infer.`,\r\n            estimatedEffort: 'trivial',\r\n            tags: ['type-assertion', 'type-safety', 'unnecessary-assertion'],\r\n          })\r\n        );\r\n      }\r\n    }\r\n\r\n    return issues;\r\n  }\r\n\r\n  /**\r\n   * Find all 'any' type usage in the AST\r\n   */\r\n  private findAnyTypeUsage(ast: SourceFile): Node[] {\r\n    const anyNodes: Node[] = [];\r\n\r\n    // Find nodes with 'any' keyword\r\n    const traverse = (node: Node) => {\r\n      // Check if this is an 'any' type reference\r\n      if (node.getKind() === SyntaxKind.AnyKeyword) {\r\n        anyNodes.push(node);\r\n      }\r\n      \r\n      node.forEachChild(traverse);\r\n    };\r\n\r\n    traverse(ast);\r\n    return anyNodes;\r\n  }\r\n\r\n  /**\r\n   * Get the context of an 'any' type usage\r\n   */\r\n  private getAnyTypeContext(node: Node): string {\r\n    let parent = node.getParent();\r\n    \r\n    // Traverse up to find the meaningful context\r\n    while (parent) {\r\n      const kind = parent.getKind();\r\n      \r\n      if (kind === SyntaxKind.Parameter) {\r\n        const paramName = this.getNodeName(parent) || 'parameter';\r\n        return `function parameter '${paramName}'`;\r\n      }\r\n      \r\n      if (kind === SyntaxKind.VariableDeclaration) {\r\n        const varName = this.getNodeName(parent) || 'variable';\r\n        return `variable declaration '${varName}'`;\r\n      }\r\n      \r\n      if (kind === SyntaxKind.PropertySignature || kind === SyntaxKind.PropertyDeclaration) {\r\n        const propName = this.getNodeName(parent) || 'property';\r\n        return `property '${propName}'`;\r\n      }\r\n      \r\n      if (kind === SyntaxKind.FunctionDeclaration || \r\n          kind === SyntaxKind.MethodDeclaration ||\r\n          kind === SyntaxKind.ArrowFunction) {\r\n        const funcName = this.getNodeName(parent) || 'function';\r\n        return `return type of '${funcName}'`;\r\n      }\r\n      \r\n      if (kind === SyntaxKind.TypeAliasDeclaration) {\r\n        const typeName = this.getNodeName(parent) || 'type';\r\n        return `type alias '${typeName}'`;\r\n      }\r\n      \r\n      if (kind === SyntaxKind.InterfaceDeclaration) {\r\n        const interfaceName = this.getNodeName(parent) || 'interface';\r\n        return `interface '${interfaceName}'`;\r\n      }\r\n      \r\n      parent = parent.getParent();\r\n    }\r\n    \r\n    return 'unknown context';\r\n  }\r\n\r\n  /**\r\n   * Find all type assertions in the AST\r\n   */\r\n  private findTypeAssertions(ast: SourceFile): Node[] {\r\n    const assertions: Node[] = [];\r\n\r\n    // Find 'as' type assertions\r\n    const asAssertions = this.findNodesByKind(ast, SyntaxKind.AsExpression);\r\n    assertions.push(...asAssertions);\r\n\r\n    // Find angle bracket type assertions (TypeReference)\r\n    const typeAssertions = this.findNodesByKind(ast, SyntaxKind.TypeAssertionExpression);\r\n    assertions.push(...typeAssertions);\r\n\r\n    // Find non-null assertions (!)\r\n    const nonNullAssertions = this.findNodesByKind(ast, SyntaxKind.NonNullExpression);\r\n    assertions.push(...nonNullAssertions);\r\n\r\n    return assertions;\r\n  }\r\n\r\n  /**\r\n   * Check if a type assertion is unnecessary\r\n   */\r\n  private isTypeAssertionUnnecessary(assertion: Node): boolean {\r\n    const assertionText = assertion.getText();\r\n    \r\n    // Check for common patterns of unnecessary assertions\r\n    \r\n    // Pattern 1: Asserting to the same type as the literal\r\n    // e.g., \"hello\" as string, 123 as number, true as boolean\r\n    if (this.isLiteralToSameTypeAssertion(assertion)) {\r\n      return true;\r\n    }\r\n    \r\n    // Pattern 2: Double assertions (as any as Type)\r\n    // These are sometimes necessary for complex type conversions, so we're lenient\r\n    if (assertionText.includes(' as any as ')) {\r\n      return false; // Not flagging double assertions as they're often intentional\r\n    }\r\n    \r\n    // Pattern 3: Asserting after a type guard\r\n    // This is harder to detect statically, so we skip it for now\r\n    \r\n    // Pattern 4: Asserting to 'any' (this is caught by excessive any detection)\r\n    if (assertionText.includes(' as any') || assertionText.includes('<any>')) {\r\n      return false; // Let the 'any' detection handle this\r\n    }\r\n    \r\n    // Pattern 5: Non-null assertion on optional chaining result\r\n    // e.g., obj?.prop! - this is often unnecessary\r\n    if (assertion.getKind() === SyntaxKind.NonNullExpression) {\r\n      const expression = (assertion as any).getExpression?.();\r\n      if (expression) {\r\n        const exprText = expression.getText();\r\n        // Check if the expression uses optional chaining\r\n        if (exprText.includes('?.')) {\r\n          return true; // Likely unnecessary\r\n        }\r\n      }\r\n    }\r\n    \r\n    // For other cases, we need more sophisticated type inference\r\n    // which would require the TypeScript type checker\r\n    // For now, we're conservative and don't flag them\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Check if an assertion is from a literal to its natural type\r\n   */\r\n  private isLiteralToSameTypeAssertion(assertion: Node): boolean {\r\n    const assertionText = assertion.getText();\r\n    \r\n    // Check for string literal to string\r\n    if (assertionText.match(/[\"'`][^\"'`]*[\"'`]\\s+as\\s+string/)) {\r\n      return true;\r\n    }\r\n    \r\n    // Check for number literal to number\r\n    if (assertionText.match(/\\d+(\\.\\d+)?\\s+as\\s+number/)) {\r\n      return true;\r\n    }\r\n    \r\n    // Check for boolean literal to boolean\r\n    if (assertionText.match(/(true|false)\\s+as\\s+boolean/)) {\r\n      return true;\r\n    }\r\n    \r\n    // Check for array literal to array type\r\n    if (assertionText.match(/\\[.*\\]\\s+as\\s+.*\\[\\]/)) {\r\n      return true;\r\n    }\r\n    \r\n    // Check for object literal to object type\r\n    if (assertionText.match(/\\{.*\\}\\s+as\\s+\\{.*\\}/)) {\r\n      // This might be necessary for specific object shapes, so we're lenient\r\n      return false;\r\n    }\r\n    \r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Get the type being asserted to\r\n   */\r\n  private getAssertedType(assertion: Node): string {\r\n    const assertionText = assertion.getText();\r\n    \r\n    // Extract type from 'as Type' syntax\r\n    const asMatch = assertionText.match(/\\s+as\\s+(.+)$/);\r\n    if (asMatch) {\r\n      return asMatch[1].trim();\r\n    }\r\n    \r\n    // Extract type from '<Type>' syntax\r\n    const angleMatch = assertionText.match(/^<(.+)>/);\r\n    if (angleMatch) {\r\n      return angleMatch[1].trim();\r\n    }\r\n    \r\n    // Non-null assertion\r\n    if (assertion.getKind() === SyntaxKind.NonNullExpression) {\r\n      return 'non-null';\r\n    }\r\n    \r\n    return 'unknown';\r\n  }\r\n}\r\n\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\Development\\aluminify\\codebase-cleanup\\src\\cli\\commands\\plan.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":45,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":45,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1664,1667],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1664,1667],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":46,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":46,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1738,1741],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1738,1741],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":47,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":47,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1810,1813],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1810,1813],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":48,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":48,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1881,1884],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1881,1884],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":92,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":92,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3415,3418],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3415,3418],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":118,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":118,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4381,4384],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4381,4384],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":123,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":123,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4616,4619],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4616,4619],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":7,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Plan Command\r\n * \r\n * Generates a cleanup plan from analysis results.\r\n */\r\n\r\nimport { Command } from 'commander';\r\nimport { resolve } from 'path';\r\nimport { readFile, writeFile } from 'fs/promises';\r\nimport { CleanupPlanner } from '../../planner/index.js';\r\nimport { handleError } from '../utils/error-handler.js';\r\nimport type { ClassifiedIssues } from '../../types.js';\r\n\r\ninterface PlanOptions {\r\n  input: string;\r\n  output?: string;\r\n  format?: 'markdown' | 'json' | 'both';\r\n}\r\n\r\nexport const planCommand = new Command('plan')\r\n  .description('Generate a cleanup plan from analysis results')\r\n  .requiredOption('-i, --input <path>', 'Path to analysis results JSON file')\r\n  .option('-o, --output <path>', 'Output file path (default: ./cleanup-plan)')\r\n  .option('-f, --format <format>', 'Output format: markdown, json, or both', 'markdown')\r\n  .action(async (options: PlanOptions) => {\r\n    try {\r\n      console.log('ðŸ“‹ Generating cleanup plan from analysis results...\\n');\r\n\r\n      // Resolve paths\r\n      const inputPath = resolve(options.input);\r\n      const outputPath = options.output ? resolve(options.output) : resolve('./cleanup-plan');\r\n\r\n      // Load analysis results\r\n      console.log(`Loading analysis results from: ${inputPath}`);\r\n      const fileContent = await readFile(inputPath, 'utf-8');\r\n      const data = JSON.parse(fileContent);\r\n\r\n      // Validate data structure\r\n      if (!data.issues) {\r\n        throw new Error('Invalid analysis results file. Expected JSON with \"issues\" field.');\r\n      }\r\n\r\n      // Reconstruct ClassifiedIssues\r\n      const classified: ClassifiedIssues = {\r\n        critical: data.issues.filter((i: any) => i.severity === 'critical'),\r\n        high: data.issues.filter((i: any) => i.severity === 'high'),\r\n        medium: data.issues.filter((i: any) => i.severity === 'medium'),\r\n        low: data.issues.filter((i: any) => i.severity === 'low'),\r\n        patterns: data.patterns || [],\r\n      };\r\n\r\n      // Generate cleanup plan\r\n      console.log('Generating cleanup plan...');\r\n      const planner = new CleanupPlanner();\r\n      const plan = planner.generatePlan(classified, classified.patterns);\r\n\r\n      // Display summary\r\n      console.log('\\nðŸ“Š Cleanup Plan Summary:');\r\n      console.log('â”€'.repeat(50));\r\n      console.log(`Total Tasks: ${plan.tasks.length}`);\r\n      console.log(`Phases: ${plan.phases.length}`);\r\n      console.log(`Estimated Duration: ${plan.estimatedDuration}`);\r\n      console.log(`Overall Risk: ${plan.riskAssessment.overallRisk}`);\r\n      console.log('â”€'.repeat(50));\r\n\r\n      // Generate output\r\n      const format = options.format || 'markdown';\r\n\r\n      if (format === 'markdown' || format === 'both') {\r\n        const markdown = generateMarkdownPlan(plan);\r\n        const mdPath = `${outputPath}.md`;\r\n        await writeFile(mdPath, markdown, 'utf-8');\r\n        console.log(`âœ… Markdown plan saved to: ${mdPath}`);\r\n      }\r\n\r\n      if (format === 'json' || format === 'both') {\r\n        const jsonPath = `${outputPath}.json`;\r\n        await writeFile(jsonPath, JSON.stringify(plan, null, 2), 'utf-8');\r\n        console.log(`âœ… JSON plan saved to: ${jsonPath}`);\r\n      }\r\n\r\n      console.log('\\nâœ… Cleanup plan generation complete!\\n');\r\n\r\n    } catch (error) {\r\n      handleError(error, 'plan');\r\n    }\r\n  });\r\n\r\n/**\r\n * Generate markdown representation of cleanup plan\r\n */\r\nfunction generateMarkdownPlan(plan: any): string {\r\n  let markdown = '# Codebase Cleanup Plan\\n\\n';\r\n\r\n  // Summary\r\n  markdown += '## Summary\\n\\n';\r\n  markdown += `- **Total Tasks**: ${plan.tasks.length}\\n`;\r\n  markdown += `- **Phases**: ${plan.phases.length}\\n`;\r\n  markdown += `- **Estimated Duration**: ${plan.estimatedDuration}\\n`;\r\n  markdown += `- **Overall Risk**: ${plan.riskAssessment.overallRisk}\\n\\n`;\r\n\r\n  // Risk Assessment\r\n  if (plan.riskAssessment.highRiskTasks.length > 0) {\r\n    markdown += '## Risk Assessment\\n\\n';\r\n    markdown += `**High Risk Tasks**: ${plan.riskAssessment.highRiskTasks.length}\\n\\n`;\r\n    \r\n    if (plan.riskAssessment.mitigationStrategies.length > 0) {\r\n      markdown += '**Mitigation Strategies**:\\n';\r\n      plan.riskAssessment.mitigationStrategies.forEach((strategy: string) => {\r\n        markdown += `- ${strategy}\\n`;\r\n      });\r\n      markdown += '\\n';\r\n    }\r\n  }\r\n\r\n  // Phases\r\n  markdown += '## Execution Phases\\n\\n';\r\n  plan.phases.forEach((phase: any) => {\r\n    markdown += `### Phase ${phase.phaseNumber}: ${phase.phaseName}\\n\\n`;\r\n    markdown += `${phase.description}\\n\\n`;\r\n    markdown += `**Tasks in this phase**: ${phase.tasks.length}\\n\\n`;\r\n\r\n    phase.tasks.forEach((task: any) => {\r\n      markdown += `#### ${task.title}\\n\\n`;\r\n      markdown += `- **ID**: ${task.id}\\n`;\r\n      markdown += `- **Category**: ${task.category}\\n`;\r\n      markdown += `- **Effort**: ${task.estimatedEffort}\\n`;\r\n      markdown += `- **Risk**: ${task.riskLevel}\\n`;\r\n      markdown += `- **Requires Tests**: ${task.requiresTests ? 'Yes' : 'No'}\\n`;\r\n      \r\n      if (task.dependencies.length > 0) {\r\n        markdown += `- **Dependencies**: ${task.dependencies.join(', ')}\\n`;\r\n      }\r\n      \r\n      markdown += `\\n**Description**: ${task.description}\\n\\n`;\r\n      \r\n      if (task.actionSteps.length > 0) {\r\n        markdown += '**Action Steps**:\\n';\r\n        task.actionSteps.forEach((step: string, index: number) => {\r\n          markdown += `${index + 1}. ${step}\\n`;\r\n        });\r\n        markdown += '\\n';\r\n      }\r\n      \r\n      if (task.affectedFiles.length > 0) {\r\n        markdown += '**Affected Files**:\\n';\r\n        task.affectedFiles.slice(0, 10).forEach((file: string) => {\r\n          markdown += `- ${file}\\n`;\r\n        });\r\n        if (task.affectedFiles.length > 10) {\r\n          markdown += `- ... and ${task.affectedFiles.length - 10} more files\\n`;\r\n        }\r\n        markdown += '\\n';\r\n      }\r\n      \r\n      markdown += '---\\n\\n';\r\n    });\r\n  });\r\n\r\n  return markdown;\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\Development\\aluminify\\codebase-cleanup\\src\\cli\\commands\\report.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":56,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":56,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2236,2239],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2236,2239],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":57,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":57,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2310,2313],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2310,2313],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":58,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":58,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2382,2385],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2382,2385],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":59,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":59,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2453,2456],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2453,2456],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Report Command\r\n * \r\n * Generates a report from previously saved analysis results.\r\n */\r\n\r\nimport { Command } from 'commander';\r\nimport { resolve } from 'path';\r\nimport { readFile, writeFile } from 'fs/promises';\r\nimport { createReportGenerator } from '../../reporter/index.js';\r\nimport { handleError } from '../utils/error-handler.js';\r\nimport type { AnalysisResult, ClassifiedIssues } from '../../types.js';\r\n\r\ninterface ReportOptions {\r\n  input: string;\r\n  output?: string;\r\n  format?: 'markdown' | 'json' | 'both';\r\n}\r\n\r\nexport const reportCommand = new Command('report')\r\n  .description('Generate a report from saved analysis results')\r\n  .requiredOption('-i, --input <path>', 'Path to analysis results JSON file')\r\n  .option('-o, --output <path>', 'Output file path (default: ./cleanup-report)')\r\n  .option('-f, --format <format>', 'Output format: markdown, json, or both', 'markdown')\r\n  .action(async (options: ReportOptions) => {\r\n    try {\r\n      console.log('ðŸ“„ Generating report from analysis results...\\n');\r\n\r\n      // Resolve paths\r\n      const inputPath = resolve(options.input);\r\n      const outputPath = options.output ? resolve(options.output) : resolve('./cleanup-report');\r\n\r\n      // Load analysis results\r\n      console.log(`Loading analysis results from: ${inputPath}`);\r\n      const fileContent = await readFile(inputPath, 'utf-8');\r\n      const data = JSON.parse(fileContent);\r\n\r\n      // Validate data structure\r\n      if (!data.summary || !data.issues) {\r\n        throw new Error('Invalid analysis results file. Expected JSON with \"summary\" and \"issues\" fields.');\r\n      }\r\n\r\n      // Reconstruct AnalysisResult and ClassifiedIssues\r\n      const analysisResult: AnalysisResult = {\r\n        totalFiles: data.summary.totalFiles || 0,\r\n        analyzedFiles: data.summary.analyzedFiles || 0,\r\n        totalIssues: data.summary.totalIssues || 0,\r\n        issuesByType: new Map(),\r\n        issuesByCategory: new Map(),\r\n        issuesBySeverity: new Map(),\r\n        analysisTimestamp: new Date(data.summary.analysisTimestamp || Date.now()),\r\n        analysisDuration: data.summary.analysisDuration || 0,\r\n      };\r\n\r\n      const classified: ClassifiedIssues = {\r\n        critical: data.issues.filter((i: any) => i.severity === 'critical'),\r\n        high: data.issues.filter((i: any) => i.severity === 'high'),\r\n        medium: data.issues.filter((i: any) => i.severity === 'medium'),\r\n        low: data.issues.filter((i: any) => i.severity === 'low'),\r\n        patterns: data.patterns || [],\r\n      };\r\n\r\n      // Generate report\r\n      const reporter = createReportGenerator();\r\n      const format = options.format || 'markdown';\r\n\r\n      if (format === 'markdown' || format === 'both') {\r\n        const markdownReport = reporter.generateMarkdownReport(analysisResult, classified);\r\n        const mdPath = `${outputPath}.md`;\r\n        await writeFile(mdPath, markdownReport, 'utf-8');\r\n        console.log(`âœ… Markdown report saved to: ${mdPath}`);\r\n      }\r\n\r\n      if (format === 'json' || format === 'both') {\r\n        const jsonReport = reporter.generateJsonReport(analysisResult, classified);\r\n        const jsonPath = `${outputPath}.json`;\r\n        await writeFile(jsonPath, JSON.stringify(jsonReport, null, 2), 'utf-8');\r\n        console.log(`âœ… JSON report saved to: ${jsonPath}`);\r\n      }\r\n\r\n      console.log('\\nâœ… Report generation complete!\\n');\r\n\r\n    } catch (error) {\r\n      handleError(error, 'report');\r\n    }\r\n  });\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\Development\\aluminify\\codebase-cleanup\\src\\types.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":158,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":158,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5126,5129],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5126,5129],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":195,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":195,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6203,6206],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6203,6206],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Core type definitions for the codebase cleanup and refactoring analysis system\r\n */\r\n\r\n// ============================================================================\r\n// File Information Types\r\n// ============================================================================\r\n\r\n/**\r\n * Categorization of files for analysis purposes\r\n */\r\nexport type FileCategory =\r\n  | 'component'      // React components\r\n  | 'api-route'      // Next.js API routes\r\n  | 'service'        // Backend services\r\n  | 'type'           // Type definition files\r\n  | 'util'           // Utility functions\r\n  | 'middleware'     // Middleware files\r\n  | 'config'         // Configuration files\r\n  | 'test'           // Test files\r\n  | 'other';         // Uncategorized\r\n\r\n/**\r\n * Information about a file to be analyzed\r\n */\r\nexport interface FileInfo {\r\n  path: string;              // Absolute path\r\n  relativePath: string;      // Relative to project root\r\n  extension: string;         // '.ts', '.tsx', etc.\r\n  size: number;             // File size in bytes\r\n  category: FileCategory;   // Categorization for analysis\r\n  lastModified: Date;       // File modification timestamp\r\n}\r\n\r\n// ============================================================================\r\n// Issue Types\r\n// ============================================================================\r\n\r\n/**\r\n * Types of issues that can be detected\r\n */\r\nexport type IssueType =\r\n  | 'backward-compatibility'\r\n  | 'legacy-code'\r\n  | 'unnecessary-adapter'\r\n  | 'confusing-logic'\r\n  | 'code-duplication'\r\n  | 'inconsistent-pattern'\r\n  | 'poor-naming'\r\n  | 'missing-error-handling'\r\n  | 'type-safety'\r\n  | 'architectural';\r\n\r\n/**\r\n * Categories for grouping issues\r\n */\r\nexport type IssueCategory =\r\n  | 'authentication'\r\n  | 'database'\r\n  | 'api-routes'\r\n  | 'components'\r\n  | 'services'\r\n  | 'types'\r\n  | 'middleware'\r\n  | 'error-handling'\r\n  | 'general';\r\n\r\n/**\r\n * Severity levels for issues\r\n */\r\nexport type Severity = 'critical' | 'high' | 'medium' | 'low';\r\n\r\n/**\r\n * Effort levels for fixing issues\r\n */\r\nexport type EffortLevel = 'trivial' | 'small' | 'medium' | 'large';\r\n\r\n/**\r\n * Precise location of code within a file\r\n */\r\nexport interface CodeLocation {\r\n  startLine: number;\r\n  endLine: number;\r\n  startColumn: number;\r\n  endColumn: number;\r\n}\r\n\r\n/**\r\n * Represents a detected issue in the codebase\r\n */\r\nexport interface Issue {\r\n  id: string;                    // Unique identifier (UUID)\r\n  type: IssueType;              // Type of issue\r\n  severity: Severity;           // Severity level\r\n  category: IssueCategory;      // Category for grouping\r\n  file: string;                 // File path\r\n  location: CodeLocation;       // Precise location in file\r\n  description: string;          // Human-readable description\r\n  codeSnippet: string;         // Relevant code excerpt\r\n  recommendation: string;       // Suggested fix\r\n  estimatedEffort: EffortLevel; // Effort to fix\r\n  tags: string[];              // Additional tags for filtering\r\n  detectedBy: string;          // Analyzer that detected it\r\n  detectedAt: Date;            // Detection timestamp\r\n  relatedIssues: string[];     // IDs of related issues\r\n}\r\n\r\n// ============================================================================\r\n// Pattern Types\r\n// ============================================================================\r\n\r\n/**\r\n * Represents a pattern of related issues across the codebase\r\n */\r\nexport interface IssuePattern {\r\n  patternId: string;           // Unique pattern identifier\r\n  patternName: string;         // Human-readable name\r\n  description: string;         // Pattern description\r\n  occurrences: number;         // Number of times detected\r\n  affectedFiles: string[];     // Files where pattern appears\r\n  relatedIssues: Issue[];      // Issues that match this pattern\r\n  recommendedAction: string;   // How to address the pattern\r\n  priority: number;            // Priority for addressing (1-10)\r\n  category: IssueCategory;     // Category for grouping\r\n}\r\n\r\n// ============================================================================\r\n// Scanner Types\r\n// ============================================================================\r\n\r\n/**\r\n * Options for scanning directories\r\n */\r\nexport interface ScanOptions {\r\n  includePatterns: string[];  // e.g., [\"**/*.ts\", \"**/*.tsx\"]\r\n  excludePatterns: string[];  // e.g., [\"**/node_modules/**\", \"**/.next/**\"]\r\n  maxDepth?: number;          // Maximum directory depth\r\n}\r\n\r\n/**\r\n * Interface for file scanning functionality\r\n */\r\nexport interface FileScanner {\r\n  scanDirectory(rootPath: string, options: ScanOptions): Promise<FileInfo[]>;\r\n  filterByPattern(files: FileInfo[], patterns: string[]): FileInfo[];\r\n  excludeByPattern(files: FileInfo[], patterns: string[]): FileInfo[];\r\n}\r\n\r\n// ============================================================================\r\n// Analyzer Types\r\n// ============================================================================\r\n\r\n/**\r\n * Base interface for all pattern analyzers\r\n */\r\nexport interface PatternAnalyzer {\r\n  name: string;\r\n  analyze(file: FileInfo, ast: any): Promise<Issue[]>;\r\n  getSupportedFileTypes(): FileCategory[];\r\n}\r\n\r\n// ============================================================================\r\n// Analysis Engine Types\r\n// ============================================================================\r\n\r\n/**\r\n * Collection of issues with various groupings\r\n */\r\nexport interface IssueCollection {\r\n  issues: Issue[];\r\n  groupedByFile: Map<string, Issue[]>;\r\n  groupedByType: Map<IssueType, Issue[]>;\r\n  groupedByCategory: Map<IssueCategory, Issue[]>;\r\n}\r\n\r\n/**\r\n * Result of analyzing the codebase\r\n */\r\nexport interface AnalysisResult {\r\n  totalFiles: number;\r\n  analyzedFiles: number;\r\n  totalIssues: number;\r\n  issuesByType: Map<IssueType, Issue[]>;\r\n  issuesByCategory: Map<IssueCategory, Issue[]>;\r\n  issuesBySeverity: Map<Severity, Issue[]>;\r\n  analysisTimestamp: Date;\r\n  analysisDuration: number;\r\n}\r\n\r\n/**\r\n * Interface for the analysis engine\r\n */\r\nexport interface AnalysisEngine {\r\n  analyze(files: FileInfo[], analyzers: PatternAnalyzer[]): Promise<AnalysisResult>;\r\n  parseFile(file: FileInfo): Promise<any>;\r\n  aggregateIssues(issues: Issue[]): IssueCollection;\r\n}\r\n\r\n// ============================================================================\r\n// Classifier Types\r\n// ============================================================================\r\n\r\n/**\r\n * Issues classified by severity\r\n */\r\nexport interface ClassifiedIssues {\r\n  critical: Issue[];\r\n  high: Issue[];\r\n  medium: Issue[];\r\n  low: Issue[];\r\n  patterns: IssuePattern[];\r\n}\r\n\r\n/**\r\n * Interface for issue classification\r\n */\r\nexport interface IssueClassifier {\r\n  classify(issues: Issue[]): ClassifiedIssues;\r\n  prioritize(issues: Issue[]): Issue[];\r\n  detectPatterns(issues: Issue[]): IssuePattern[];\r\n}\r\n\r\n// ============================================================================\r\n// Report Types\r\n// ============================================================================\r\n\r\n/**\r\n * Summary of the analysis report\r\n */\r\nexport interface ReportSummary {\r\n  totalIssues: number;\r\n  criticalIssues: number;\r\n  highIssues: number;\r\n  mediumIssues: number;\r\n  lowIssues: number;\r\n  topPatterns: IssuePattern[];\r\n  mostAffectedFiles: string[];\r\n  estimatedCleanupEffort: string;\r\n}\r\n\r\n/**\r\n * Recommendation for addressing issues\r\n */\r\nexport interface Recommendation {\r\n  priority: number;\r\n  title: string;\r\n  description: string;\r\n  affectedIssues: string[];\r\n  estimatedImpact: string;\r\n  estimatedEffort: string;\r\n}\r\n\r\n/**\r\n * Complete report data structure\r\n */\r\nexport interface ReportData {\r\n  summary: ReportSummary;\r\n  issues: Issue[];\r\n  patterns: IssuePattern[];\r\n  recommendations: Recommendation[];\r\n}\r\n\r\n/**\r\n * Interface for report generation\r\n */\r\nexport interface ReportGenerator {\r\n  generateMarkdownReport(result: AnalysisResult, classified: ClassifiedIssues): string;\r\n  generateJsonReport(result: AnalysisResult, classified: ClassifiedIssues): ReportData;\r\n  generateSummary(result: AnalysisResult): ReportSummary;\r\n}\r\n\r\n// ============================================================================\r\n// Cleanup Planning Types\r\n// ============================================================================\r\n\r\n/**\r\n * Risk levels for cleanup tasks\r\n */\r\nexport type RiskLevel = 'low' | 'medium' | 'high' | 'critical';\r\n\r\n/**\r\n * A specific cleanup task to address issues\r\n */\r\nexport interface CleanupTask {\r\n  id: string;                  // Unique task identifier\r\n  title: string;               // Short task title\r\n  description: string;         // Detailed description\r\n  category: IssueCategory;     // Category for grouping\r\n  relatedIssues: string[];     // Issue IDs this task addresses\r\n  dependencies: string[];      // Task IDs that must complete first\r\n  estimatedEffort: EffortLevel; // Effort estimate\r\n  riskLevel: RiskLevel;        // Risk of making this change\r\n  requiresTests: boolean;      // Whether tests needed before change\r\n  actionSteps: string[];       // Step-by-step instructions\r\n  affectedFiles: string[];     // Files that will be modified\r\n  phase: number;               // Which phase this belongs to\r\n}\r\n\r\n/**\r\n * Dependency relationship between tasks\r\n */\r\nexport interface TaskDependency {\r\n  taskId: string;\r\n  dependsOn: string[];\r\n  reason: string;\r\n}\r\n\r\n/**\r\n * A phase of cleanup work\r\n */\r\nexport interface CleanupPhase {\r\n  phaseNumber: number;\r\n  phaseName: string;\r\n  tasks: CleanupTask[];\r\n  description: string;\r\n}\r\n\r\n/**\r\n * Risk assessment for the cleanup plan\r\n */\r\nexport interface RiskAssessment {\r\n  overallRisk: RiskLevel;\r\n  highRiskTasks: CleanupTask[];\r\n  mitigationStrategies: string[];\r\n}\r\n\r\n/**\r\n * Complete cleanup plan\r\n */\r\nexport interface CleanupPlan {\r\n  tasks: CleanupTask[];\r\n  phases: CleanupPhase[];\r\n  estimatedDuration: string;\r\n  riskAssessment: RiskAssessment;\r\n}\r\n\r\n/**\r\n * Interface for cleanup planning\r\n */\r\nexport interface ICleanupPlanner {\r\n  generatePlan(classified: ClassifiedIssues, patterns: IssuePattern[]): CleanupPlan;\r\n  orderTasks(tasks: CleanupTask[]): CleanupTask[];\r\n  detectDependencies(tasks: CleanupTask[]): TaskDependency[];\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\Development\\aluminify\\codebase-cleanup\\src\\utils\\ast-parser.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":256,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":256,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7455,7458],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7455,7458],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":484,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":484,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14001,14004],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14001,14004],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":505,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":505,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14542,14545],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14542,14545],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":512,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":512,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14721,14724],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14721,14724],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * AST Parsing Utilities\r\n * \r\n * Provides utilities for parsing TypeScript/JavaScript files into ASTs\r\n * and querying AST nodes for common patterns.\r\n */\r\n\r\nimport { Project, SourceFile, Node, SyntaxKind } from 'ts-morph';\r\nimport type { FileInfo } from '../types';\r\n\r\n/**\r\n * Error thrown when file parsing fails\r\n */\r\nexport class ParseError extends Error {\r\n  constructor(\r\n    message: string,\r\n    public readonly filePath: string,\r\n    public readonly cause?: Error\r\n  ) {\r\n    super(message);\r\n    this.name = 'ParseError';\r\n  }\r\n}\r\n\r\n/**\r\n * AST Parser class for parsing files and querying AST nodes\r\n */\r\nexport class ASTParser {\r\n  private project: Project;\r\n\r\n  constructor() {\r\n    // Initialize ts-morph Project with TypeScript compiler options\r\n    this.project = new Project({\r\n      compilerOptions: {\r\n        target: 99, // ESNext\r\n        module: 99, // ESNext\r\n        jsx: 2, // React\r\n        allowJs: true,\r\n        skipLibCheck: true,\r\n        skipDefaultLibCheck: true,\r\n        noEmit: true,\r\n      },\r\n      skipAddingFilesFromTsConfig: true,\r\n      skipFileDependencyResolution: true,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Parse a file into an AST\r\n   * @param file File information\r\n   * @returns Parsed SourceFile AST\r\n   * @throws ParseError if parsing fails\r\n   */\r\n  async parseFile(file: FileInfo): Promise<SourceFile> {\r\n    try {\r\n      // Add the file to the project\r\n      const sourceFile = this.project.addSourceFileAtPath(file.path);\r\n      \r\n      // Check for syntax errors\r\n      const diagnostics = sourceFile.getPreEmitDiagnostics();\r\n      \r\n      if (diagnostics.length > 0) {\r\n        // Log diagnostics but don't fail - we want to analyze even files with errors\r\n        const errors = diagnostics.map(d => d.getMessageText()).join('\\n');\r\n        console.warn(`Syntax warnings in ${file.relativePath}:\\n${errors}`);\r\n      }\r\n      \r\n      return sourceFile;\r\n    } catch (error) {\r\n      throw new ParseError(\r\n        `Failed to parse file: ${file.relativePath}`,\r\n        file.path,\r\n        error instanceof Error ? error : undefined\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Parse file content from a string\r\n   * @param content File content as string\r\n   * @param filePath Virtual file path for the content\r\n   * @returns Parsed SourceFile AST\r\n   * @throws ParseError if parsing fails\r\n   */\r\n  parseContent(content: string, filePath: string): SourceFile {\r\n    try {\r\n      return this.project.createSourceFile(filePath, content, { overwrite: true });\r\n    } catch (error) {\r\n      throw new ParseError(\r\n        `Failed to parse content for: ${filePath}`,\r\n        filePath,\r\n        error instanceof Error ? error : undefined\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Remove a file from the project to free memory\r\n   * @param sourceFile Source file to remove\r\n   */\r\n  removeFile(sourceFile: SourceFile): void {\r\n    sourceFile.forget();\r\n  }\r\n\r\n  /**\r\n   * Clear all files from the project\r\n   */\r\n  clearAll(): void {\r\n    this.project.getSourceFiles().forEach(sf => sf.forget());\r\n  }\r\n\r\n  /**\r\n   * Get the ts-morph Project instance\r\n   * @returns The Project instance\r\n   */\r\n  getProject(): Project {\r\n    return this.project;\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// AST Query Helpers\r\n// ============================================================================\r\n\r\n/**\r\n * Query helper functions for common AST operations\r\n */\r\nexport class ASTQueryHelper {\r\n  /**\r\n   * Find all function declarations in a source file\r\n   * @param ast Source file AST\r\n   * @returns Array of function declaration nodes\r\n   */\r\n  static findFunctions(ast: SourceFile): Node[] {\r\n    return ast.getDescendantsOfKind(SyntaxKind.FunctionDeclaration);\r\n  }\r\n\r\n  /**\r\n   * Find all arrow functions in a source file\r\n   * @param ast Source file AST\r\n   * @returns Array of arrow function nodes\r\n   */\r\n  static findArrowFunctions(ast: SourceFile): Node[] {\r\n    return ast.getDescendantsOfKind(SyntaxKind.ArrowFunction);\r\n  }\r\n\r\n  /**\r\n   * Find all function expressions in a source file\r\n   * @param ast Source file AST\r\n   * @returns Array of function expression nodes\r\n   */\r\n  static findFunctionExpressions(ast: SourceFile): Node[] {\r\n    return ast.getDescendantsOfKind(SyntaxKind.FunctionExpression);\r\n  }\r\n\r\n  /**\r\n   * Find all functions (declarations, expressions, and arrow functions)\r\n   * @param ast Source file AST\r\n   * @returns Array of all function nodes\r\n   */\r\n  static findAllFunctions(ast: SourceFile): Node[] {\r\n    return [\r\n      ...this.findFunctions(ast),\r\n      ...this.findArrowFunctions(ast),\r\n      ...this.findFunctionExpressions(ast),\r\n    ];\r\n  }\r\n\r\n  /**\r\n   * Find all method declarations in a source file\r\n   * @param ast Source file AST\r\n   * @returns Array of method declaration nodes\r\n   */\r\n  static findMethods(ast: SourceFile): Node[] {\r\n    return ast.getDescendantsOfKind(SyntaxKind.MethodDeclaration);\r\n  }\r\n\r\n  /**\r\n   * Find all class declarations in a source file\r\n   * @param ast Source file AST\r\n   * @returns Array of class declaration nodes\r\n   */\r\n  static findClasses(ast: SourceFile): Node[] {\r\n    return ast.getDescendantsOfKind(SyntaxKind.ClassDeclaration);\r\n  }\r\n\r\n  /**\r\n   * Find all interface declarations in a source file\r\n   * @param ast Source file AST\r\n   * @returns Array of interface declaration nodes\r\n   */\r\n  static findInterfaces(ast: SourceFile): Node[] {\r\n    return ast.getDescendantsOfKind(SyntaxKind.InterfaceDeclaration);\r\n  }\r\n\r\n  /**\r\n   * Find all type alias declarations in a source file\r\n   * @param ast Source file AST\r\n   * @returns Array of type alias nodes\r\n   */\r\n  static findTypeAliases(ast: SourceFile): Node[] {\r\n    return ast.getDescendantsOfKind(SyntaxKind.TypeAliasDeclaration);\r\n  }\r\n\r\n  /**\r\n   * Find all type definitions (interfaces and type aliases)\r\n   * @param ast Source file AST\r\n   * @returns Array of type definition nodes\r\n   */\r\n  static findTypes(ast: SourceFile): Node[] {\r\n    return [\r\n      ...this.findInterfaces(ast),\r\n      ...this.findTypeAliases(ast),\r\n    ];\r\n  }\r\n\r\n  /**\r\n   * Find all import declarations in a source file\r\n   * @param ast Source file AST\r\n   * @returns Array of import declaration nodes\r\n   */\r\n  static findImports(ast: SourceFile): Node[] {\r\n    return ast.getDescendantsOfKind(SyntaxKind.ImportDeclaration);\r\n  }\r\n\r\n  /**\r\n   * Find all export declarations in a source file\r\n   * @param ast Source file AST\r\n   * @returns Array of export declaration nodes\r\n   */\r\n  static findExports(ast: SourceFile): Node[] {\r\n    return ast.getDescendantsOfKind(SyntaxKind.ExportDeclaration);\r\n  }\r\n\r\n  /**\r\n   * Find all variable declarations in a source file\r\n   * @param ast Source file AST\r\n   * @returns Array of variable declaration nodes\r\n   */\r\n  static findVariables(ast: SourceFile): Node[] {\r\n    return ast.getDescendantsOfKind(SyntaxKind.VariableDeclaration);\r\n  }\r\n\r\n  /**\r\n   * Find all const declarations in a source file\r\n   * @param ast Source file AST\r\n   * @returns Array of const variable declaration nodes\r\n   */\r\n  static findConstants(ast: SourceFile): Node[] {\r\n    const variableStatements = ast.getDescendantsOfKind(SyntaxKind.VariableStatement);\r\n    const constants: Node[] = [];\r\n\r\n    for (const statement of variableStatements) {\r\n      const declarationList = statement.getFirstChildByKind(SyntaxKind.VariableDeclarationList);\r\n      if (declarationList) {\r\n        const flags = (declarationList as any).getDeclarationKind?.();\r\n        if (flags === 2) { // VariableDeclarationKind.Const\r\n          constants.push(...declarationList.getDescendantsOfKind(SyntaxKind.VariableDeclaration));\r\n        }\r\n      }\r\n    }\r\n\r\n    return constants;\r\n  }\r\n\r\n  /**\r\n   * Find all if statements in a source file\r\n   * @param ast Source file AST\r\n   * @returns Array of if statement nodes\r\n   */\r\n  static findIfStatements(ast: SourceFile): Node[] {\r\n    return ast.getDescendantsOfKind(SyntaxKind.IfStatement);\r\n  }\r\n\r\n  /**\r\n   * Find all for statements in a source file\r\n   * @param ast Source file AST\r\n   * @returns Array of for statement nodes\r\n   */\r\n  static findForStatements(ast: SourceFile): Node[] {\r\n    return ast.getDescendantsOfKind(SyntaxKind.ForStatement);\r\n  }\r\n\r\n  /**\r\n   * Find all while statements in a source file\r\n   * @param ast Source file AST\r\n   * @returns Array of while statement nodes\r\n   */\r\n  static findWhileStatements(ast: SourceFile): Node[] {\r\n    return ast.getDescendantsOfKind(SyntaxKind.WhileStatement);\r\n  }\r\n\r\n  /**\r\n   * Find all switch statements in a source file\r\n   * @param ast Source file AST\r\n   * @returns Array of switch statement nodes\r\n   */\r\n  static findSwitchStatements(ast: SourceFile): Node[] {\r\n    return ast.getDescendantsOfKind(SyntaxKind.SwitchStatement);\r\n  }\r\n\r\n  /**\r\n   * Find all try statements in a source file\r\n   * @param ast Source file AST\r\n   * @returns Array of try statement nodes\r\n   */\r\n  static findTryStatements(ast: SourceFile): Node[] {\r\n    return ast.getDescendantsOfKind(SyntaxKind.TryStatement);\r\n  }\r\n\r\n  /**\r\n   * Find all catch clauses in a source file\r\n   * @param ast Source file AST\r\n   * @returns Array of catch clause nodes\r\n   */\r\n  static findCatchClauses(ast: SourceFile): Node[] {\r\n    return ast.getDescendantsOfKind(SyntaxKind.CatchClause);\r\n  }\r\n\r\n  /**\r\n   * Find all call expressions in a source file\r\n   * @param ast Source file AST\r\n   * @returns Array of call expression nodes\r\n   */\r\n  static findCallExpressions(ast: SourceFile): Node[] {\r\n    return ast.getDescendantsOfKind(SyntaxKind.CallExpression);\r\n  }\r\n\r\n  /**\r\n   * Find all JSX elements in a source file\r\n   * @param ast Source file AST\r\n   * @returns Array of JSX element nodes\r\n   */\r\n  static findJSXElements(ast: SourceFile): Node[] {\r\n    return [\r\n      ...ast.getDescendantsOfKind(SyntaxKind.JsxElement),\r\n      ...ast.getDescendantsOfKind(SyntaxKind.JsxSelfClosingElement),\r\n    ];\r\n  }\r\n\r\n  /**\r\n   * Find all React component declarations (function components)\r\n   * @param ast Source file AST\r\n   * @returns Array of React component nodes\r\n   */\r\n  static findReactComponents(ast: SourceFile): Node[] {\r\n    const components: Node[] = [];\r\n    \r\n    // Find function declarations that return JSX\r\n    const functions = [\r\n      ...this.findFunctions(ast),\r\n      ...this.findArrowFunctions(ast),\r\n      ...this.findFunctionExpressions(ast),\r\n    ];\r\n\r\n    for (const func of functions) {\r\n      const text = func.getText();\r\n      // Check if function returns JSX (contains JSX syntax)\r\n      if (text.includes('<') && text.includes('/>') || text.includes('</')) {\r\n        components.push(func);\r\n      }\r\n    }\r\n\r\n    return components;\r\n  }\r\n\r\n  /**\r\n   * Find all nodes with 'any' type annotation\r\n   * @param ast Source file AST\r\n   * @returns Array of nodes with 'any' type\r\n   */\r\n  static findAnyTypes(ast: SourceFile): Node[] {\r\n    return ast.getDescendantsOfKind(SyntaxKind.AnyKeyword);\r\n  }\r\n\r\n  /**\r\n   * Find all type assertions (as Type)\r\n   * @param ast Source file AST\r\n   * @returns Array of type assertion nodes\r\n   */\r\n  static findTypeAssertions(ast: SourceFile): Node[] {\r\n    return ast.getDescendantsOfKind(SyntaxKind.AsExpression);\r\n  }\r\n\r\n  /**\r\n   * Find all comments in a source file\r\n   * @param ast Source file AST\r\n   * @returns Array of comment texts\r\n   */\r\n  static findComments(ast: SourceFile): string[] {\r\n    const comments: string[] = [];\r\n    const fullText = ast.getFullText();\r\n    \r\n    // Get all comment ranges\r\n    ast.forEachDescendant(node => {\r\n      const leadingComments = node.getLeadingCommentRanges();\r\n      const trailingComments = node.getTrailingCommentRanges();\r\n      \r\n      for (const range of [...leadingComments, ...trailingComments]) {\r\n        const commentText = fullText.substring(range.getPos(), range.getEnd());\r\n        comments.push(commentText);\r\n      }\r\n    });\r\n    \r\n    return comments;\r\n  }\r\n\r\n  /**\r\n   * Find all commented-out code blocks\r\n   * @param ast Source file AST\r\n   * @returns Array of commented code blocks\r\n   */\r\n  static findCommentedCode(ast: SourceFile): string[] {\r\n    const comments = this.findComments(ast);\r\n    const commentedCode: string[] = [];\r\n    \r\n    for (const comment of comments) {\r\n      // Remove comment markers\r\n      const cleaned = comment\r\n        .replace(/^\\/\\*+/, '')\r\n        .replace(/\\*+\\/$/, '')\r\n        .replace(/^\\/\\/+/gm, '')\r\n        .trim();\r\n      \r\n      // Check if it looks like code (has common code patterns)\r\n      const codePatterns = [\r\n        /function\\s+\\w+/,\r\n        /const\\s+\\w+\\s*=/,\r\n        /let\\s+\\w+\\s*=/,\r\n        /var\\s+\\w+\\s*=/,\r\n        /class\\s+\\w+/,\r\n        /interface\\s+\\w+/,\r\n        /type\\s+\\w+\\s*=/,\r\n        /import\\s+.*from/,\r\n        /export\\s+(default|const|function|class)/,\r\n        /if\\s*\\(/,\r\n        /for\\s*\\(/,\r\n        /while\\s*\\(/,\r\n        /=>\\s*{/,\r\n      ];\r\n      \r\n      if (codePatterns.some(pattern => pattern.test(cleaned))) {\r\n        commentedCode.push(comment);\r\n      }\r\n    }\r\n    \r\n    return commentedCode;\r\n  }\r\n\r\n  /**\r\n   * Find nodes by custom predicate\r\n   * @param ast Source file AST\r\n   * @param predicate Function to test each node\r\n   * @returns Array of matching nodes\r\n   */\r\n  static findByPredicate(ast: SourceFile, predicate: (node: Node) => boolean): Node[] {\r\n    const matches: Node[] = [];\r\n    \r\n    ast.forEachDescendant(node => {\r\n      if (predicate(node)) {\r\n        matches.push(node);\r\n      }\r\n    });\r\n    \r\n    return matches;\r\n  }\r\n\r\n  /**\r\n   * Find nodes by syntax kind\r\n   * @param ast Source file AST\r\n   * @param kind Syntax kind to search for\r\n   * @returns Array of matching nodes\r\n   */\r\n  static findByKind(ast: SourceFile, kind: SyntaxKind): Node[] {\r\n    return ast.getDescendantsOfKind(kind);\r\n  }\r\n\r\n  /**\r\n   * Get the name of a named node (function, class, variable, etc.)\r\n   * @param node AST node\r\n   * @returns Name of the node or undefined\r\n   */\r\n  static getNodeName(node: Node): string | undefined {\r\n    const nodeWithName = node as any;\r\n    \r\n    if (nodeWithName.getName && typeof nodeWithName.getName === 'function') {\r\n      return nodeWithName.getName();\r\n    }\r\n    \r\n    if (nodeWithName.name) {\r\n      return typeof nodeWithName.name === 'string' \r\n        ? nodeWithName.name \r\n        : nodeWithName.name.getText?.();\r\n    }\r\n    \r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Check if a node is exported\r\n   * @param node AST node\r\n   * @returns True if the node is exported\r\n   */\r\n  static isExported(node: Node): boolean {\r\n    const nodeWithModifiers = node as any;\r\n    \r\n    if (!nodeWithModifiers.getModifiers) {\r\n      return false;\r\n    }\r\n    \r\n    const modifiers = nodeWithModifiers.getModifiers();\r\n    return modifiers.some((mod: any) => \r\n      mod.getKind() === SyntaxKind.ExportKeyword\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Calculate the cyclomatic complexity of a function\r\n   * @param node Function node\r\n   * @returns Complexity score\r\n   */\r\n  static calculateComplexity(node: Node): number {\r\n    let complexity = 1; // Base complexity\r\n    \r\n    // Count decision points\r\n    const decisionPoints = [\r\n      SyntaxKind.IfStatement,\r\n      SyntaxKind.ConditionalExpression,\r\n      SyntaxKind.CaseClause,\r\n      SyntaxKind.ForStatement,\r\n      SyntaxKind.ForInStatement,\r\n      SyntaxKind.ForOfStatement,\r\n      SyntaxKind.WhileStatement,\r\n      SyntaxKind.DoStatement,\r\n      SyntaxKind.CatchClause,\r\n      SyntaxKind.BinaryExpression, // For && and ||\r\n    ];\r\n    \r\n    node.forEachDescendant(child => {\r\n      if (decisionPoints.includes(child.getKind())) {\r\n        // For binary expressions, only count logical operators\r\n        if (child.getKind() === SyntaxKind.BinaryExpression) {\r\n          const text = child.getText();\r\n          if (text.includes('&&') || text.includes('||')) {\r\n            complexity++;\r\n          }\r\n        } else {\r\n          complexity++;\r\n        }\r\n      }\r\n    });\r\n    \r\n    return complexity;\r\n  }\r\n\r\n  /**\r\n   * Calculate the nesting depth of a node\r\n   * @param node AST node\r\n   * @returns Maximum nesting depth\r\n   */\r\n  static calculateNestingDepth(node: Node): number {\r\n    let maxDepth = 0;\r\n    \r\n    const traverse = (n: Node, depth: number) => {\r\n      maxDepth = Math.max(maxDepth, depth);\r\n      \r\n      const kind = n.getKind();\r\n      const nestingKinds = [\r\n        SyntaxKind.IfStatement,\r\n        SyntaxKind.ForStatement,\r\n        SyntaxKind.ForInStatement,\r\n        SyntaxKind.ForOfStatement,\r\n        SyntaxKind.WhileStatement,\r\n        SyntaxKind.DoStatement,\r\n        SyntaxKind.SwitchStatement,\r\n        SyntaxKind.TryStatement,\r\n        SyntaxKind.CatchClause,\r\n      ];\r\n      \r\n      const newDepth = nestingKinds.includes(kind) ? depth + 1 : depth;\r\n      \r\n      n.forEachChild(child => traverse(child, newDepth));\r\n    };\r\n    \r\n    traverse(node, 0);\r\n    return maxDepth;\r\n  }\r\n\r\n  /**\r\n   * Get all identifiers in a node\r\n   * @param node AST node\r\n   * @returns Array of identifier names\r\n   */\r\n  static getIdentifiers(node: Node): string[] {\r\n    const identifiers: string[] = [];\r\n    \r\n    node.forEachDescendant(child => {\r\n      if (child.getKind() === SyntaxKind.Identifier) {\r\n        identifiers.push(child.getText());\r\n      }\r\n    });\r\n    \r\n    return identifiers;\r\n  }\r\n\r\n  /**\r\n   * Check if a node contains a specific pattern\r\n   * @param node AST node\r\n   * @param pattern Regular expression pattern\r\n   * @returns True if pattern is found\r\n   */\r\n  static containsPattern(node: Node, pattern: RegExp): boolean {\r\n    return pattern.test(node.getText());\r\n  }\r\n}\r\n\r\n/**\r\n * Export a singleton instance of ASTParser for convenience\r\n */\r\nexport const astParser = new ASTParser();\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\Development\\aluminify\\codebase-cleanup\\test-arrow-detailed-debug.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":25,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":25,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[572,575],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[572,575],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":56,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":56,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1508,1511],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1508,1511],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":71,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":71,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2011,2014],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2011,2014],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":86,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":86,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2468,2471],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2468,2471],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Detailed debug test for arrow function detection\r\n */\r\n\r\nimport { Project, Node } from 'ts-morph';\r\n\r\nasync function testArrowFunctionAnalysis() {\r\n  console.log('Detailed arrow function analysis...\\n');\r\n\r\n  const project = new Project({\r\n    useInMemoryFileSystem: true,\r\n    compilerOptions: {\r\n      target: 99,\r\n      module: 99,\r\n    },\r\n  });\r\n\r\n  const code = `\r\n    const fetchUser = (userId: string) => database.getUser(userId);\r\n  `;\r\n\r\n  const sourceFile = project.createSourceFile('test.ts', code);\r\n  \r\n  // Find the arrow function\r\n  let arrowFunc: any = null;\r\n  sourceFile.forEachDescendant((node) => {\r\n    if (Node.isArrowFunction(node)) {\r\n      arrowFunc = node;\r\n    }\r\n  });\r\n\r\n  if (!arrowFunc) {\r\n    console.log('No arrow function found!');\r\n    return;\r\n  }\r\n\r\n  console.log('Arrow function found!');\r\n  console.log('Full text:', arrowFunc.getText());\r\n  \r\n  const body = arrowFunc.getBody();\r\n  console.log('\\nBody kind:', body.getKindName());\r\n  console.log('Body text:', body.getText());\r\n  console.log('Body is Block?', Node.isBlock(body));\r\n  console.log('Body is CallExpression?', Node.isCallExpression(body));\r\n  \r\n  // Check if body is a call expression\r\n  if (Node.isCallExpression(body)) {\r\n    console.log('\\nâœ“ Body is a call expression (expression body)');\r\n    console.log('Call text:', body.getText());\r\n    \r\n    const expression = body.getExpression();\r\n    console.log('Expression:', expression.getText());\r\n  }\r\n  \r\n  // Get statements\r\n  let statements: any[] = [];\r\n  if (Node.isBlock(body)) {\r\n    statements = body.getStatements();\r\n    console.log('\\nStatements in block:', statements.length);\r\n  } else {\r\n    statements = [body];\r\n    console.log('\\nExpression body (single statement)');\r\n  }\r\n  \r\n  console.log('Statement count:', statements.length);\r\n  statements.forEach((stmt, i) => {\r\n    console.log(`  Statement ${i}: ${stmt.getKindName()} - ${stmt.getText().substring(0, 50)}`);\r\n  });\r\n  \r\n  // Get call expressions\r\n  const callExpressions: any[] = [];\r\n  body.forEachDescendant((node) => {\r\n    if (Node.isCallExpression(node)) {\r\n      callExpressions.push(node);\r\n    }\r\n  });\r\n  \r\n  console.log('\\nCall expressions found:', callExpressions.length);\r\n  callExpressions.forEach((call, i) => {\r\n    console.log(`  Call ${i}: ${call.getText()}`);\r\n  });\r\n  \r\n  // Get parameters\r\n  const params = arrowFunc.getParameters();\r\n  console.log('\\nParameters:', params.length);\r\n  params.forEach((param: any) => {\r\n    console.log(`  - ${param.getName()}`);\r\n  });\r\n}\r\n\r\ntestArrowFunctionAnalysis().catch(console.error);\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\Development\\aluminify\\codebase-cleanup\\test-arrow-function-debug.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":45,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":45,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1189,1192],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1189,1192],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":52,"column":54,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":52,"endColumn":57,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1575,1578],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1575,1578],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Debug test for arrow function detection\r\n */\r\n\r\nimport { Project } from 'ts-morph';\r\nimport { AdapterPatternAnalyzer } from './src/analyzers/adapter-pattern-analyzer';\r\nimport type { FileInfo } from './src/types';\r\n\r\nfunction createFileInfo(path: string): FileInfo {\r\n  return {\r\n    path: `/test/${path}`,\r\n    relativePath: path,\r\n    extension: '.ts',\r\n    size: 1000,\r\n    category: 'util',\r\n  };\r\n}\r\n\r\nasync function testArrowFunctions() {\r\n  console.log('Testing arrow function detection...\\n');\r\n\r\n  const project = new Project({\r\n    useInMemoryFileSystem: true,\r\n    compilerOptions: {\r\n      target: 99,\r\n      module: 99,\r\n    },\r\n  });\r\n\r\n  const code = `\r\n    const fetchUser = (userId: string) => database.getUser(userId);\r\n    \r\n    const checkAuth = (userId: string) => supabase.auth.getUser(userId);\r\n    \r\n    const verifyUser = (id: string) => authService.verify(id);\r\n  `;\r\n\r\n  const sourceFile = project.createSourceFile('test.ts', code);\r\n  \r\n  // Check what functions are found\r\n  console.log('Functions found in AST:');\r\n  const functions = sourceFile.getFunctions();\r\n  console.log(`  Regular functions: ${functions.length}`);\r\n  \r\n  const arrowFunctions: any[] = [];\r\n  sourceFile.forEachDescendant((node) => {\r\n    if (node.getKindName() === 'ArrowFunction') {\r\n      arrowFunctions.push(node);\r\n      const parent = node.getParent();\r\n      console.log(`  Arrow function found, parent: ${parent?.getKindName()}`);\r\n      if (parent && parent.getKindName() === 'VariableDeclaration') {\r\n        console.log(`    Variable name: ${(parent as any).getName()}`);\r\n      }\r\n    }\r\n  });\r\n  console.log(`  Arrow functions: ${arrowFunctions.length}\\n`);\r\n\r\n  const analyzer = new AdapterPatternAnalyzer();\r\n  const issues = await analyzer.analyze(createFileInfo('test.ts'), sourceFile);\r\n  \r\n  console.log(`Issues found: ${issues.length}`);\r\n  issues.forEach(issue => {\r\n    console.log(`  - ${issue.description}`);\r\n  });\r\n}\r\n\r\ntestArrowFunctions().catch(console.error);\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\Development\\aluminify\\codebase-cleanup\\test-export-detection.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":28,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":28,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[861,864],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[861,864],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":38,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":38,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1309,1312],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1309,1312],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":39,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":39,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1378,1381],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1378,1381],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":41,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":41,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1534,1537],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1534,1537],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Test export detection for variable declarations\r\n */\r\n\r\nimport { Project, SyntaxKind } from 'ts-morph';\r\n\r\nasync function testExportDetection() {\r\n  console.log('Testing Export Detection...\\n');\r\n\r\n  const project = new Project();\r\n  \r\n  const code = `\r\n    export const passthrough = (req: Request, res: Response, next: NextFunction) => next();\r\n    export const noop = (req: any, res: any, next: any) => next();\r\n    const notExported = () => {};\r\n  `;\r\n\r\n  const sourceFile = project.createSourceFile('test.ts', code);\r\n  \r\n  const varDecls = sourceFile.getVariableDeclarations();\r\n  \r\n  console.log('Variable declarations found:');\r\n  varDecls.forEach(varDecl => {\r\n    const name = varDecl.getName();\r\n    console.log(`\\n  Variable: ${name}`);\r\n    \r\n    // Check modifiers on the variable declaration itself\r\n    const declModifiers = (varDecl as any).getModifiers?.() || [];\r\n    console.log(`    Modifiers on declaration: ${declModifiers.length}`);\r\n    \r\n    // Check modifiers on the parent variable statement\r\n    const parent = varDecl.getParent();\r\n    console.log(`    Parent type: ${parent.getKindName()}`);\r\n    \r\n    const parentParent = parent.getParent();\r\n    console.log(`    Parent's parent type: ${parentParent?.getKindName()}`);\r\n    \r\n    if (parentParent && (parentParent as any).getModifiers) {\r\n      const parentModifiers = (parentParent as any).getModifiers();\r\n      console.log(`    Modifiers on parent's parent: ${parentModifiers.length}`);\r\n      const hasExport = parentModifiers.some((mod: any) => \r\n        mod.getKind() === SyntaxKind.ExportKeyword\r\n      );\r\n      console.log(`    Has export keyword: ${hasExport}`);\r\n    }\r\n  });\r\n}\r\n\r\ntestExportDetection().catch(console.error);\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\Development\\aluminify\\codebase-cleanup\\test-middleware-detailed-debug.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":12,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":12,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[432,435],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[432,435],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":77,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":77,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2466,2469],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2466,2469],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":90,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":90,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2965,2968],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2965,2968],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":95,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":95,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3176,3179],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3176,3179],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":95,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":95,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3184,3187],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3184,3187],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":96,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":96,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3229,3232],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3229,3232],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Detailed debug test to trace middleware usage extraction\r\n */\r\n\r\nimport { Project } from 'ts-morph';\r\nimport { MiddlewarePatternAnalyzer } from './src/analyzers/middleware-pattern-analyzer';\r\nimport type { FileInfo } from './src/types';\r\n\r\n// Extend the analyzer to expose internal state for debugging\r\nclass DebugMiddlewareAnalyzer extends MiddlewarePatternAnalyzer {\r\n  public getMiddlewareUsages() {\r\n    return (this as any).middlewareUsages;\r\n  }\r\n}\r\n\r\nasync function detailedDebug() {\r\n  console.log('Detailed Middleware Usage Debug...\\n');\r\n\r\n  const analyzer = new DebugMiddlewareAnalyzer();\r\n  const project = new Project();\r\n\r\n  // Create middleware library\r\n  const middlewareLib = `\r\n    export function authenticateMiddleware(req: Request, res: Response, next: NextFunction) {\r\n      console.log('Authenticating...');\r\n      next();\r\n    }\r\n\r\n    export function authorizeMiddleware(req: Request, res: Response, next: NextFunction) {\r\n      console.log('Authorizing...');\r\n      next();\r\n    }\r\n  `;\r\n\r\n  const libFile = project.createSourceFile('middleware/auth.ts', middlewareLib);\r\n  await analyzer.analyze({\r\n    path: '/test/middleware/auth.ts',\r\n    relativePath: 'middleware/auth.ts',\r\n    extension: '.ts',\r\n    size: middlewareLib.length,\r\n    category: 'middleware',\r\n    lastModified: new Date(),\r\n  }, libFile);\r\n\r\n  console.log('After analyzing middleware library:');\r\n  console.log('Usages:', analyzer.getMiddlewareUsages());\r\n  console.log();\r\n\r\n  // Create route with wrong order\r\n  const routeCode = `\r\n    import { authenticateMiddleware, authorizeMiddleware } from '../middleware/auth';\r\n\r\n    export async function GET(req: Request) {\r\n      // Wrong order: authorize before authenticate\r\n      authorizeMiddleware(req, res, next);\r\n      authenticateMiddleware(req, res, next);\r\n      \r\n      return Response.json({ data: 'success' });\r\n    }\r\n  `;\r\n\r\n  const routeFile = project.createSourceFile('app/api/test/route.ts', routeCode);\r\n  \r\n  console.log('Analyzing route file...');\r\n  const routeIssues = await analyzer.analyze({\r\n    path: '/test/app/api/test/route.ts',\r\n    relativePath: 'app/api/test/route.ts',\r\n    extension: '.ts',\r\n    size: routeCode.length,\r\n    category: 'api-route',\r\n    lastModified: new Date(),\r\n  }, routeFile);\r\n\r\n  console.log('\\nAfter analyzing route:');\r\n  const usages = analyzer.getMiddlewareUsages();\r\n  console.log(`Total usages tracked: ${usages.length}`);\r\n  usages.forEach((usage: any, idx: number) => {\r\n    console.log(`  Usage ${idx + 1}:`);\r\n    console.log(`    Middleware name: \"${usage.middlewareName}\"`);\r\n    console.log(`    Route file: ${usage.routeFile}`);\r\n    console.log(`    Order: ${usage.order}`);\r\n  });\r\n  console.log();\r\n\r\n  console.log('Route issues found:');\r\n  if (routeIssues.length === 0) {\r\n    console.log('  âš ï¸  No issues found!');\r\n    console.log('\\nLet me check what the ordering detection sees:');\r\n    \r\n    const routeUsages = usages.filter((u: any) => u.routeFile === 'app/api/test/route.ts');\r\n    console.log(`  Usages for this route: ${routeUsages.length}`);\r\n    \r\n    if (routeUsages.length > 0) {\r\n      const order = routeUsages\r\n        .sort((a: any, b: any) => a.order - b.order)\r\n        .map((u: any) => u.middlewareName.toLowerCase());\r\n      \r\n      console.log(`  Order array: [${order.join(', ')}]`);\r\n      \r\n      const authIndex = order.findIndex((name: string) => \r\n        name.includes('auth') || name.includes('authenticate')\r\n      );\r\n      const authorizeIndex = order.findIndex((name: string) => \r\n        name.includes('authorize') || name.includes('permission')\r\n      );\r\n      \r\n      console.log(`  Auth index: ${authIndex} (looking for 'auth' or 'authenticate')`);\r\n      console.log(`  Authorize index: ${authorizeIndex} (looking for 'authorize' or 'permission')`);\r\n      console.log(`  Should trigger anti-pattern: ${authIndex > authorizeIndex && authIndex >= 0 && authorizeIndex >= 0}`);\r\n    }\r\n  } else {\r\n    routeIssues.forEach(issue => {\r\n      console.log(`  - [${issue.severity}] ${issue.description}`);\r\n    });\r\n  }\r\n}\r\n\r\ndetailedDebug().catch(console.error);\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\Development\\aluminify\\codebase-cleanup\\test-rate-limit-debug.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":11,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":11,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[342,345],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[342,345],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":73,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":73,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2293,2296],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2293,2296],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":78,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":78,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2426,2429],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2426,2429],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":80,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":80,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2520,2523],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2520,2523],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":80,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":80,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2528,2531],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2528,2531],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":81,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":81,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2569,2572],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2569,2572],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Debug rate limiting detection\r\n */\r\n\r\nimport { Project } from 'ts-morph';\r\nimport { MiddlewarePatternAnalyzer } from './src/analyzers/middleware-pattern-analyzer';\r\nimport type { FileInfo } from './src/types';\r\n\r\nclass DebugMiddlewareAnalyzer extends MiddlewarePatternAnalyzer {\r\n  public getMiddlewareUsages() {\r\n    return (this as any).middlewareUsages;\r\n  }\r\n}\r\n\r\nasync function debugRateLimit() {\r\n  console.log('Debugging Rate Limit Detection...\\n');\r\n\r\n  const analyzer = new DebugMiddlewareAnalyzer();\r\n  const project = new Project();\r\n\r\n  // Create middleware\r\n  const middlewareLib = `\r\n    export function rateLimitMiddleware(req: Request, res: Response, next: NextFunction) {\r\n      next();\r\n    }\r\n    export function businessLogic1(req: Request, res: Response, next: NextFunction) {\r\n      next();\r\n    }\r\n    export function businessLogic2(req: Request, res: Response, next: NextFunction) {\r\n      next();\r\n    }\r\n    export function businessLogic3(req: Request, res: Response, next: NextFunction) {\r\n      next();\r\n    }\r\n  `;\r\n\r\n  const libFile = project.createSourceFile('middleware/lib.ts', middlewareLib);\r\n  await analyzer.analyze({\r\n    path: '/test/middleware/lib.ts',\r\n    relativePath: 'middleware/lib.ts',\r\n    extension: '.ts',\r\n    size: middlewareLib.length,\r\n    category: 'middleware',\r\n    lastModified: new Date(),\r\n  }, libFile);\r\n\r\n  // Create route with rate limit at the end\r\n  const routeCode = `\r\n    import { businessLogic1, businessLogic2, businessLogic3, rateLimitMiddleware } from '../middleware/lib';\r\n\r\n    export async function POST(req: Request) {\r\n      businessLogic1(req, res, next);\r\n      businessLogic2(req, res, next);\r\n      businessLogic3(req, res, next);\r\n      rateLimitMiddleware(req, res, next);\r\n      \r\n      return Response.json({ data: 'created' });\r\n    }\r\n  `;\r\n\r\n  const routeFile = project.createSourceFile('app/api/test/route.ts', routeCode);\r\n  const routeIssues = await analyzer.analyze({\r\n    path: '/test/app/api/test/route.ts',\r\n    relativePath: 'app/api/test/route.ts',\r\n    extension: '.ts',\r\n    size: routeCode.length,\r\n    category: 'api-route',\r\n    lastModified: new Date(),\r\n  }, routeFile);\r\n\r\n  console.log('Usages tracked:');\r\n  const usages = analyzer.getMiddlewareUsages();\r\n  usages.forEach((u: any) => {\r\n    console.log(`  ${u.order}: ${u.middlewareName}`);\r\n  });\r\n  console.log();\r\n\r\n  const routeUsages = usages.filter((u: any) => u.routeFile === 'app/api/test/route.ts');\r\n  const order = routeUsages\r\n    .sort((a: any, b: any) => a.order - b.order)\r\n    .map((u: any) => u.middlewareName.toLowerCase());\r\n  \r\n  console.log(`Order array: [${order.join(', ')}]`);\r\n  \r\n  const rateLimitIndex = order.findIndex((name: string) => \r\n    name.includes('ratelimit') || name.includes('rate-limit') || name.includes('throttle')\r\n  );\r\n  \r\n  console.log(`Rate limit index: ${rateLimitIndex}`);\r\n  console.log(`Should trigger (index > 2): ${rateLimitIndex > 2}`);\r\n  console.log();\r\n\r\n  console.log('Issues found:');\r\n  if (routeIssues.length === 0) {\r\n    console.log('  âš ï¸  No issues!');\r\n  } else {\r\n    routeIssues.forEach(issue => {\r\n      console.log(`  - [${issue.severity}] ${issue.description.substring(0, 100)}`);\r\n    });\r\n  }\r\n}\r\n\r\ndebugRateLimit().catch(console.error);\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\Development\\aluminify\\components\\theme-customizer\\content-layout-selector.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":16,"column":80,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":16,"endColumn":83,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[561,564],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[561,564],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\"use client\";\r\n\r\nimport { Label } from \"@/components/ui/label\";\r\nimport { useThemeConfig } from \"@/components/active-theme\";\r\nimport { ToggleGroup, ToggleGroupItem } from \"@/components/ui/toggle-group\";\r\n\r\nexport function ContentLayoutSelector() {\r\n  const { theme, setTheme } = useThemeConfig();\r\n\r\n  return (\r\n    <div className=\"hidden flex-col gap-4 lg:flex\">\r\n      <Label>Content layout</Label>\r\n      <ToggleGroup\r\n        value={theme.contentLayout}\r\n        type=\"single\"\r\n        onValueChange={(value) => setTheme({ ...theme, contentLayout: value as any })}\r\n        className=\"*:border-input w-full gap-4 *:rounded-md *:border\">\r\n        <ToggleGroupItem variant=\"outline\" value=\"full\">\r\n          Full\r\n        </ToggleGroupItem>\r\n        <ToggleGroupItem\r\n          variant=\"outline\"\r\n          value=\"centered\"\r\n          className=\"data-[variant=outline]:border-l-1\">\r\n          Centered\r\n        </ToggleGroupItem>\r\n      </ToggleGroup>\r\n    </div>\r\n  );\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\Development\\aluminify\\components\\theme-customizer\\preset-selector.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":18,"column":61,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":18,"endColumn":64,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[496,499],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[496,499],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\"use client\";\r\n\r\nimport { DEFAULT_THEME, THEMES } from \"@/lib/themes\";\r\nimport { useThemeConfig } from \"@/components/active-theme\";\r\nimport {\r\n  Select,\r\n  SelectContent,\r\n  SelectItem,\r\n  SelectTrigger,\r\n  SelectValue\r\n} from \"@/components/ui/select\";\r\nimport { Label } from \"@/components/ui/label\";\r\n\r\nexport function PresetSelector() {\r\n  const { theme, setTheme } = useThemeConfig();\r\n\r\n  const handlePreset = (value: string) => {\r\n    setTheme({ ...theme, ...DEFAULT_THEME, preset: value as any });\r\n  };\r\n\r\n  return (\r\n    <div className=\"flex flex-col gap-4\">\r\n      <Label>Theme preset:</Label>\r\n      <Select value={theme.preset} onValueChange={(value) => handlePreset(value)}>\r\n        <SelectTrigger className=\"w-full\">\r\n          <SelectValue placeholder=\"Select a theme\" />\r\n        </SelectTrigger>\r\n        <SelectContent align=\"end\">\r\n          {THEMES.map((theme) => (\r\n            <SelectItem key={theme.name} value={theme.value}>\r\n              <div className=\"flex shrink-0 gap-1\">\r\n                {theme.colors.map((color, key) => (\r\n                  <span\r\n                    key={key}\r\n                    className=\"size-2 rounded-full\"\r\n                    style={{ backgroundColor: color }}></span>\r\n                ))}\r\n              </div>\r\n              {theme.name}\r\n            </SelectItem>\r\n          ))}\r\n        </SelectContent>\r\n      </Select>\r\n    </div>\r\n  );\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\Development\\aluminify\\components\\ui\\custom\\minimal-tiptap\\extensions\\code-block-lowlight\\code-block-lowlight.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":8,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":8,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[325,328],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[325,328],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { CodeBlockLowlight as TiptapCodeBlockLowlight } from \"@tiptap/extension-code-block-lowlight\";\r\nimport { common, createLowlight } from \"lowlight\";\r\n\r\nexport const CodeBlockLowlight = TiptapCodeBlockLowlight.extend({\r\n  addOptions() {\r\n    return {\r\n      ...this.parent?.(),\r\n      lowlight: createLowlight(common) as any,\r\n      defaultLanguage: null,\r\n      HTMLAttributes: {\r\n        class: \"block-node\",\r\n      },\r\n    };\r\n  },\r\n});\r\n\r\nexport default CodeBlockLowlight;\r\n","usedDeprecatedRules":[]}]
